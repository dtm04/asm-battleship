Microsoft (R) Macro Assembler Version 14.22.27905.0	    08/10/19 22:40:17
Battleship.asm						     Page 1 - 1


				; -------------------------------------------
				;			Battleship
				; Don MacPhail, Mohammed Khan
				;	
				;	Sources: 
				;		http://programming.msjc.edu/asm/help/index.html?page=source%2Fwinstruct%2Finput_record.htm
				;		https://www.csee.umbc.edu/courses/undergraduate/CMSC313/fall04/burt_katz/lectures/Lect01/ASCII.html
				;		Irvine text book
				;		stackoverflow
				;		masm32.com
				;	Code inspired by and some procedures adapted from github.com/andrewpryan
				;	Don - Programming
				;	Mohammed - Documentation & Research
				;	Assembly @ WIT with Durga Suresh-Menon
				;	Summer 2019 (senior year!?)
				;	License: None, who cares.  
				;	Contact:
				;		macphaild@wit.edu
				;		khanm@wit.edu


				INCLUDE Irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C ; Last update: 7/29/05
			      C 
			      C ;----------------------------------------
			      C ; Procedure Prototypes
			      C ;----------------------------------------
			      C CloseFile PROTO		; close a file handle
			      C Clrscr PROTO		; clear the screen
			      C CreateOutputFile PROTO		; create file for writing
			      C Crlf PROTO		; output carriage-return / linefeed
			      C Delay PROTO		; delay for n milliseconds
			      C DumpMem PROTO		; display memory dump
			      C DumpRegs PROTO		; display register dump
			      C GetCommandTail PROTO		; get command-line string
			      C GetDateTime PROTO,		; get system date and time
			      C   startTime:PTR QWORD
			      C GetMaxXY PROTO		; get console rows and columns
			      C GetMseconds PROTO		; get milliseconds past midnight
			      C GetTextColor PROTO		; Get the console window's color attributes. 
			      C Gotoxy PROTO		; set the cursor position
			      C IsDigit PROTO		; return ZF=1 if AL is a decimal digit
			      C MsgBox PROTO		; display popup message box
			      C MsgBoxAsk PROTO		; display popup yes/no question box
			      C OpenInputFile PROTO		; open file in input mode
			      C ParseDecimal32 PROTO		; convert unsigned decimal string to 32-bit binary
			      C ParseInteger32 PROTO		; convert signed decimal string to 32-bit binary
			      C Randomize PROTO		; reseed random number generator
			      C RandomRange PROTO		; generate random integer in specified range
			      C Random32 PROTO		; generate 32-bit random integer
			      C ReadInt PROTO		; read signed decimal integer from console
			      C ReadChar PROTO		; reach single character from console
			      C ReadDec PROTO		; read unsigned decimal integer from console
			      C ReadFloat PROTO		; read floating-point value from keyboard
			      C ReadFromFile PROTO   		; read buffer from input file
			      C ReadHex PROTO		; read hexadecimal integer from console
			      C ReadKey PROTO		; Reads keyboard input if available (4/6/03)
			      C ReadKeyFlush PROTO		; Flush ReadKey buffer and repeat counter (4/6/03)
			      C ReadString PROTO		; read string from console
			      C SetTextColor PROTO		; set console text color
			      C ShowFPUStack PROTO		; write floating-point stack to console window
			      C StrLength PROTO		; returns the length of a string
			      C WaitMsg PROTO		; display wait message, wait for Enter key
			      C WriteBin PROTO		; write integer to output in binary format
			      C WriteBinB PROTO		; write binary integer in byte, word,or doubleword format
			      C WriteChar PROTO		; write single character to output
			      C WriteDec PROTO		; write unsigned decimal integer to output
			      C WriteFloat PROTO		; write ST(0) to console in floating-point format
			      C WriteHex PROTO		; write hexadecimal integer to output
			      C WriteHexB PROTO		; write hexadecimal integer in word or doubleword format
			      C WriteInt PROTO		; write signed integer to output
			      C ;WriteStackFrame		; write stack frame data (James Brink--see proto later in this file)
			      C ;WriteStackFrameName		; write stack frame data with proc name (James Brink)
			      C WriteString PROTO		; write null-terminated string to output
			      C WriteToFile PROTO		; write a buffer to an output file
			      C WriteWindowsMsg PROTO		; write last error message generated by MS-Windows
			      C 
			      C 
			      C ; Copy a source string to a target string.
			      C Str_copy PROTO,
			      C  	source:PTR BYTE,
			      C  	target:PTR BYTE
			      C 
			      C ; Return the length of a null-terminated string..
			      C Str_length PROTO,
			      C 	pString:PTR BYTE
			      C 
			      C ; Compare string1 to string2. Set the Zero and
			      C ; Carry flags in the same way as the CMP instruction.
			      C Str_compare PROTO,
			      C 	string1:PTR BYTE,
			      C 	string2:PTR BYTE
			      C 
			      C ; Trim a given trailing character from a string.
			      C ; The second argument is the character to trim.
			      C Str_trim PROTO,
			      C 	pString:PTR BYTE,
			      C 	char:BYTE
			      C 
			      C ; Convert a null-terminated string to upper case.
			      C Str_ucase PROTO,
			      C 	pString:PTR BYTE
			      C 
			      C ;******** Procedures by James Brink ********************************
			      C ; Used by permission.
			      C 
			      C WriteStackFrameName PROTO,
			      C            numParam:DWORD,     ; number of parameters passed to the procedure
			      C            numLocalVal: DWORD, ; number of DWordLocal variables
			      C            numSavedReg: DWORD, ; number of saved registers
			      C            procName: PTR BYTE
			      C 
			      C WriteStackFrame PROTO,
			      C            numParam:DWORD,     ; number of parameters passed to the procedure
			      C            numLocalVal: DWORD, ; number of DWordLocal variables
			      C            numSavedReg: DWORD  ; number of saved registers
			      C 
			      C 
			      C ;-----------------------------------
			      C ; Standard 4-bit color definitions
			      C ;-----------------------------------
 = 00000000		      C black        = 0000b
 = 00000001		      C blue         = 0001b
 = 00000002		      C green        = 0010b
 = 00000003		      C cyan         = 0011b
 = 00000004		      C red          = 0100b
 = 00000005		      C magenta      = 0101b
 = 00000006		      C brown        = 0110b
 = 00000007		      C lightGray    = 0111b
 = 00000008		      C gray         = 1000b
 = 00000009		      C lightBlue    = 1001b
 = 0000000A		      C lightGreen   = 1010b
 = 0000000B		      C lightCyan    = 1011b
 = 0000000C		      C lightRed     = 1100b
 = 0000000D		      C lightMagenta = 1101b
 = 0000000E		      C yellow       = 1110b
 = 0000000F		      C white        = 1111b
			      C 
			      C ; This structure is returned by the FSTSW
			      C ; instruction in protected mode:
			      C 
 0000001C		      C FPU_ENVIRON STRUCT
 00000000  0000		      C 	controlWord    WORD ?
			      C 	ALIGN DWORD
 00000004  0000		      C 	statusWord     WORD ?
			      C 	ALIGN DWORD
 00000008  0000		      C 	tagWord        WORD ?
			      C 	ALIGN DWORD
 0000000C  00000000	      C 	instrPointerOffset     DWORD ?
 00000010  00000000	      C 	instrPointerSelector   DWORD ?
 00000014  00000000	      C 	operandPointerOffset   DWORD ?
 00000018  0000		      C 	operandPointerSelector WORD ?
 0000001A  0000		      C 	WORD ?	; not used
			      C FPU_ENVIRON ENDS
			      C 
			      C .LIST
			      C 
				INCLUDE Macros.inc
			      C COMMENT !
			      C ; (Macros.inc) - Include file containing Macros
			      C ; for Assembly Language for Intel-Based Computers
			      C ; 7th Edition, by Kip Irvine. Copyright 2014, Prentice-Hall Inc,
			      C ; all rights reserved.
			      C ;
			      C ; Update history:
			      C ; 1/1/2014 - Revised for 7th Edition
			      C 
			      C ; List of macros in this file:
			      C 
			      C mDump MACRO varName:REQ, useLabel
			      C 	-- Displays a variable, using its name and default attributes.
			      C 	-- useLabel is optional; if nonblank, the variable name will be displayed
			      C 	--    just before the dump.
			      C 
			      C mDumpMem MACRO address:REQ, itemCount:REQ, componentSize:REQ
			      C 	-- Displays a dump of a range of memory.
			      C 
			      C mGotoxy MACRO X:REQ, Y:REQ
			      C 	-- Sets the cursor position.
			      C 
			      C mReadString MACRO varName:REQ
			      C 	-- Reads a string from the keyboard.
			      C 
			      C mShow MACRO itsName:REQ, format:=<HIN>
			      C 	-- Displays a variable or register in various formats.
			      C 
			      C mShowRegister MACRO regName, regValue
			      C 	-- Displays a 32-bit register name and contents in hexadecimal.
			      C 
			      C mWrite MACRO text:REQ
			      C 	-- Writes a string literal to standard output.
			      C 
			      C mWriteLn MACRO text:REQ
			      C 	-- Writes a string literal to standard output.  *** DEPRECATED in 5th Edition ***
			      C 
			      C mWriteSpace MACRO count
			      C 	-- Writes one or more spaces to the console window.
			      C 	-- <count> is optional
			      C 
			      C mWriteString MACRO buffer:REQ
			      C 	-- Writes a string variable's contents to the console window.
			      C 
			      C 
			      C 
			      C END COMMENT ***************************************** !
			      C 
			      C ; Introduced in Chapter 10 as an example of a Macro function.
			      C 
			      C IsDefined MACRO symbol
			      C     IFDEF symbol
			      C         EXITM <-1>              ; True
			      C     ELSE
			      C         EXITM <0>               ; False
			      C     ENDIF
			      C ENDM
			      C 
			      C ;----------------------------------------------------
			      C mDump MACRO varName:REQ, useLabel
			      C ;
			      C ; Displays a variable, using its known attributes
			      C ; Receives: varName, the name of a variable.
			      C ;    If useLabel is nonblank, the name of the
			      C ;    variable is displayed.
			      C ;----------------------------------------------------
			      C 	call Crlf
			      C 	IFNB <useLabel>
			      C 	  mWrite "Variable name: &varName"
			      C 	ELSE
			      C 	  mWrite " "
			      C 	ENDIF
			      C 	mDumpMem OFFSET varName, LENGTHOF varName, TYPE varName
			      C ENDM
			      C 
			      C ;------------------------------------------------------
			      C mDumpMem MACRO address:REQ, itemCount:REQ, componentSize:REQ
			      C ;
			      C ; Receives: memory offset, count of the number of items
			      C ;   to display, and the size of each memory component.
			      C ; Avoid passing EBX, ECX, and ESI as arguments.
			      C ;------------------------------------------------------
			      C 	push	ebx
			      C 	push	ecx
			      C 	push	esi
			      C 	mov	esi,address
			      C 	mov	ecx,itemCount
			      C 	mov	ebx,componentSize
			      C 	call	DumpMem
			      C 	pop	esi
			      C 	pop	ecx
			      C 	pop	ebx
			      C ENDM
			      C 
			      C ;------------------------------------------------------
			      C mGotoxy MACRO X:REQ, Y:REQ
			      C ;  
			      C ; Sets the cursor position. 
			      C ; Receives: X and Y coordinates (type BYTE). Avoid 
			      C ;    passing DH and DL as arguments.
			      C ;------------------------------------------------------
			      C 	push edx
			      C 	mov  dh,Y
			      C 	mov  dl,X
			      C 	call Gotoxy
			      C 	pop  edx
			      C ENDM
			      C 
			      C ;------------------------------------------------------
			      C mReadString MACRO varName:REQ
			      C ;
			      C ; Reads from standard input into a buffer.
			      C ; Receives: the name of the buffer. Avoid passing 
			      C ;    ECX and EDX as arguments.
			      C ;------------------------------------------------------
			      C 	push ecx
			      C 	push edx
			      C 	mov  edx,OFFSET varName
			      C 	mov  ecx,SIZEOF varName
			      C 	call ReadString
			      C 	pop  edx
			      C 	pop  ecx
			      C ENDM
			      C 
			      C ;---------------------------------------------------
			      C mShow MACRO itsName:REQ, format:=<HIN>
			      C              LOCAL tempStr
			      C ; Displays a register's or variable's name and contents.
			      C ;
			      C ; Receives:
			      C ;	itsName is the name of a register or variable.
			      C ; 	format is an ordered string consisting of the format codes:
			      C ;	  H - hexadecimal
			      C ;	  D - unsigned decimal
			      C ;     I - signed decimal
			      C ;     B - binary
			      C ;     N - append a newline (CR/LF) (may appear multiple times)
			      C ;
			      C ; The default format is "HIN"
			      C ;
			      C ; The variable or register's value is displayed in each format,
			      C ; in the order specified by the caller, on a single output line.
			      C ; Create by Gerald Cahill and Kip Irvine.
			      C ;---------------------------------------------------
			      C .data
			      C tempStr BYTE "  &itsName = ",0
			      C .code
			      C     pushad
			      C 
			      C ;;If itsName is a register name, define its type
			      C 
			      C IF (OPATTR (itsName)) AND 00010000b ;;true if register name
			      C 
			      C   MSHOWITSNAMETYPE = 0 ;; initialize TYPE to not found
			      C 
			      C   FOR reg8,<al,ah,bl,bh,cl,ch,dl,dh>
			      C     IFIDNI <itsName>,<reg8>
			      C       MSHOWITSNAMETYPE = 1
			      C       movzx ecx,itsName  ;; get unsigned value
			      C       movsx edx,itsName  ;; get signed value
			      C     ENDIF
			      C   ENDM
			      C 
			      C   FOR reg16,<ax,bx,cx,dx,si,di,bp,sp>
			      C     IFIDNI <itsName>,<reg16>
			      C       MSHOWITSNAMETYPE = 2
			      C       movzx ecx,itsName  ;; get unsigned value
			      C       movsx edx,itsName  ;; get signed value
			      C     ENDIF
			      C   ENDM
			      C 
			      C   FOR regseg,<cs,ds,es,fs,gs,ss>
			      C     IFIDNI <itsName>,<regseg>
			      C       MSHOWITSNAMETYPE = 2
			      C       mov   ax,itsName  ;; get value into general purpose reg.
			      C       movsx edx,ax      ;; get signed value (who would want it?)
			      C       movzx ecx,ax      ;; get unsigned value
			      C     ENDIF
			      C   ENDM
			      C 
			      C   FOR reg32,<eax,ebx,ecx,edx,esi,edi,ebp,esp>
			      C     IFIDNI <itsName>,<reg32>
			      C       MSHOWITSNAMETYPE = 4
			      C       mov   ecx,itsName  ;; get unsigned value
			      C       mov   edx,itsName  ;; get signed value
			      C     ENDIF
			      C   ENDM
			      C 
			      C ELSE ;; itsName is not a register name, assume variable name
			      C 
			      C   MSHOWITSNAMETYPE = TYPE itsName
			      C   IF MSHOWITSNAMETYPE EQ 4
			      C       mov   ecx,itsName  ;; get unsigned value
			      C       mov   edx,ecx      ; get signed value
			      C   ELSE
			      C       movzx ecx,itsName  ;; get unsigned value
			      C       movsx edx,itsName  ;; get signed value
			      C   ENDIF
			      C 
			      C ENDIF ;OPATTR
			      C                          ; Display the register or variable's name
			      C     push edx
			      C     mov  edx,OFFSET tempStr
			      C     call WriteString
			      C     pop  edx
			      C 
			      C                         ; Display the register or variable's contents
			      C FORC fmt,<format>
			      C 
			      C   IFIDNI <fmt>,<H>      ;; H - write unsigned hex
			      C     mov eax,ecx         ;; get unsigned
			      C     mov ebx,MSHOWITSNAMETYPE
			      C     call WriteHexB    	;; write in hexadecimal
			      C     mWrite "h  "
			      C   ENDIF
			      C 
			      C   IFIDNI <fmt>,<D>      ;; D - write unsigned dec
			      C     mov eax,ecx         ;; get unsigned
			      C     call WriteDec
			      C     mWrite "d  "
			      C   ENDIF
			      C 
			      C   IFIDNI <fmt>,<I>      ;; I - write signed Integer
			      C     mov eax,edx         ;; get signed
			      C     call WriteInt
			      C     mWrite "d  "
			      C   ENDIF
			      C 
			      C   IFIDNI <fmt>,<B>      ;; B - write unsigned binary
			      C     mov eax,ecx         ;; get unsigned
			      C     mov ebx,MSHOWITSNAMETYPE
			      C     call WriteBinB      ;; display binary
			      C     mWrite "b  "
			      C   ENDIF
			      C 
			      C   IFIDNI <fmt>,<N>      ;; N - write new line
			      C     call Crlf
			      C   ENDIF
			      C 
			      C ENDM ;end FORC
			      C 
			      C 	popad
			      C ENDM 	;; end mShow macro
			      C 
			      C ;---------------------------------------------------
			      C mShowRegister MACRO regName, regValue
			      C LOCAL tempStr
			      C ;
			      C ; Displays a 32-bit register name and contents.
			      C ; Receives: the register name, the register value.
			      C ;---------------------------------------------------
			      C .data
			      C tempStr BYTE "  &regName=",0
			      C .code
			      C 	push eax
			      C 
			      C ; Display the register name
			      C 	push	edx
			      C 	mov	edx,OFFSET tempStr
			      C 	call	WriteString
			      C 	pop	edx
			      C 
			      C ; Display the register contents
			      C 	mov	eax,regValue
			      C 	call	WriteHex
			      C 	pop	eax
			      C ENDM
			      C 
			      C ;------------------------------------------------------
			      C mWrite MACRO text:REQ
			      C ;
			      C ; Writes a string literal to standard output.
			      C ; Receives: a string enclosed in single or double 
			      C ;   quotes (null terminator not required).
			      C ;------------------------------------------------------
			      C LOCAL string
			      C 	.data		; local data
			      C 	string BYTE text,0	;; define the string
			      C 	.code
			      C 	push	edx
			      C 	mov	edx,OFFSET string
			      C 	call	WriteString
			      C 	pop	edx
			      C ENDM
			      C 
			      C ;------------------------------------------------------
			      C mWriteLn MACRO text:REQ
			      C ;
			      C ; Writes a string literal to standard output, followined by Crlf
			      C ; Receives: a string enclosed in single or double 
			      C ;   quotes (null terminator not required).
			      C ; DEPRECATED in the Fifth edition.
			      C ;------------------------------------------------------
			      C 	mWrite text
			      C 	call	Crlf
			      C ENDM
			      C 
			      C ;------------------------------------------------------
			      C mWriteSpace MACRO count:=<1>
			      C ;
			      C ; Writes one or more spaces to standard output.
			      C ; Receives: an integer specifying the number of spaces.
			      C ;   If count is blank, a single space is written.
			      C ;------------------------------------------------------
			      C LOCAL spaces
			      C .data
			      C spaces BYTE count DUP(' '),0
			      C .code
			      C 	push	edx
			      C 	mov	edx,OFFSET spaces
			      C 	call	WriteString
			      C 	pop	edx
			      C ENDM
			      C 
			      C ;------------------------------------------------------
			      C mWriteString MACRO buffer:REQ
			      C ;
			      C ; Writes a string variable to standard output.
			      C ; Receives: string variable name.
			      C ;------------------------------------------------------
			      C 	push edx
			      C 	mov  edx,OFFSET buffer
			      C 	call WriteString
			      C 	pop  edx
			      C ENDM
			      C 
			      C 
			      C Startup MACRO
			      C 	IF IsDefined( RealMode )
			      C   	  mov ax,@data
			      C 	  mov ds,ax
			      C 	ENDIF
			      C ENDM
			      C 
			      C ;----------------------------------------------------------------------
			      C ; We may later decide to add some macros that are specific to 32-bit
			      C ; mode, or to 16-bit mode. The @MODEL value is defined either by
			      C ; Irvine16.inc or by Irvine32.inc, when they use the .MODEL directive.
			      C ;----------------------------------------------------------------------
			      C 
			      C IFDEF @MODEL	; @MODEL defined?
			      C 	IF @MODEL EQ 7	; 32-bit unique macros begin here...
			      C 
			      C 	ELSE	; 16-bit unique macros begin here...
			      C 	ENDIF	; IF @MODEL...
			      C ENDIF	; IFNDEF @MODEL
			      C 
			      C .LIST
			      C 

				.386
				.stack 4096
				ExitProcess proto,dwExitCode:dword

				; TODO:
				;	- Computer ship placement bugs need to be fixed
				;	- Proper collission detection for user ship placement
				;	- ASCII art or something cool like that

 00000000			.data
				; Messages displayed to the player that contains instructions on how to play the game.
 00000000 57 65 6C 63 6F	intro1 BYTE "Welcome to BATTLESHIP!", 13, 10, 0
	   6D 65 20 74 6F
	   20 42 41 54 54
	   4C 45 53 48 49
	   50 21 0D 0A 00
 00000019 48 6F 77 20 74	intro2 BYTE "How to play: ", 13, 10, 0
	   6F 20 70 6C 61
	   79 3A 20 0D 0A
	   00
 00000029 2D 2D 20 59 6F	intro3 BYTE "-- You have five ships: Carrier, Battleship, Submarine, Destroyer, Sweeper.", 13, 10, 0
	   75 20 68 61 76
	   65 20 66 69 76
	   65 20 73 68 69
	   70 73 3A 20 43
	   61 72 72 69 65
	   72 2C 20 42 61
	   74 74 6C 65 73
	   68 69 70 2C 20
	   53 75 62 6D 61
	   72 69 6E 65 2C
	   20 44 65 73 74
	   72 6F 79 65 72
	   2C 20 53 77 65
	   65 70 65 72 2E
	   0D 0A 00
 00000077 2D 2D 20 50 6C	intro4 BYTE "-- Place a ship on the grid by clicking.", 13, 10, 0
	   61 63 65 20 61
	   20 73 68 69 70
	   20 6F 6E 20 74
	   68 65 20 67 72
	   69 64 20 62 79
	   20 63 6C 69 63
	   6B 69 6E 67 2E
	   0D 0A 00
 000000A2 2D 2D 20 4C 65	intro5 BYTE "-- Left click: Place the ship vertically.  Right click: Place the ship horizontally.", 13, 10, 0
	   66 74 20 63 6C
	   69 63 6B 3A 20
	   50 6C 61 63 65
	   20 74 68 65 20
	   73 68 69 70 20
	   76 65 72 74 69
	   63 61 6C 6C 79
	   2E 20 20 52 69
	   67 68 74 20 63
	   6C 69 63 6B 3A
	   20 50 6C 61 63
	   65 20 74 68 65
	   20 73 68 69 70
	   20 68 6F 72 69
	   7A 6F 6E 74 61
	   6C 6C 79 2E 0D
	   0A 00
 000000F9 2D 2D 20 59 6F	intro6 BYTE "-- Your goal is to sink all ships on the computer board.", 13, 10, 0
	   75 72 20 67 6F
	   61 6C 20 69 73
	   20 74 6F 20 73
	   69 6E 6B 20 61
	   6C 6C 20 73 68
	   69 70 73 20 6F
	   6E 20 74 68 65
	   20 63 6F 6D 70
	   75 74 65 72 20
	   62 6F 61 72 64
	   2E 0D 0A 00
 00000134 50 72 65 73 73	intro7 BYTE "Press any key to continue...", 13, 10, 0
	   20 61 6E 79 20
	   6B 65 79 20 74
	   6F 20 63 6F 6E
	   74 69 6E 75 65
	   2E 2E 2E 0D 0A
	   00

				; helpers
 00000153 00			numRows BYTE ?	; 41
 00000154 00			numCols BYTE ?	; 120
 00000155 00			ShipsPlaced BYTE 0	; Increments every time a ship is placed
 00000156 00			mouseNum BYTE ?	; 1: Left, 2: Right
 00000157 00			currShipSize BYTE ?
 00000158 00			currShipChar BYTE ?
 00000159 00			currShipHealth BYTE ?
 0000015A 00			currShip BYTE ?
 0000015B 00000000		currOffset DWORD ?
 0000015F 00			hitBool BYTE 0

 00000160 00			intersect BYTE 0

				; ship char code and constants
 00000161 43			_C_ BYTE 67
 00000162 42			_B_ BYTE 66
 00000163 55			_U_ BYTE 85
 00000164 44			_D_ BYTE 68
 00000165 49			_S_ BYTE 73
 00000166 5F			_EMPTY_ byte 95
 00000167 3F			COL_MIN BYTE 63
 00000168 51			COL_MAX BYTE 81
 00000169 06			ROW_MIN BYTE 6
 0000016A 0F			ROW_MAX BYTE 15

				; Grid system using characters. Each square is a char.
				; one map for player, one map for computer
				; each map is a single array
				; Total squares:  22 x 11 = 222
				; Usable Squares: 10 x 10 = 100
				; clicks are registered by capturing x,y position
 0000016B 23 3A 20 41 7C	PlayerMap BYTE "#: A|B|C|D|E|F|G|H|I|J"
	   42 7C 43 7C 44
	   7C 45 7C 46 7C
	   47 7C 48 7C 49
	   7C 4A
 00000181  30 3A 20 5F 7C		BYTE "0: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 00000197  31 3A 20 5F 7C		BYTE "1: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 000001AD  32 3A 20 5F 7C		BYTE "2: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 000001C3  33 3A 20 5F 7C		BYTE "3: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 000001D9  34 3A 20 5F 7C		BYTE "4: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 000001EF  35 3A 20 5F 7C		BYTE "5: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 00000205  36 3A 20 5F 7C		BYTE "6: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 0000021B  37 3A 20 5F 7C		BYTE "7: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 00000231  38 3A 20 5F 7C		BYTE "8: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 00000247  39 3A 20 5F 7C		BYTE "9: _|_|_|_|_|_|_|_|_|_",0
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F 00

				; C -- Size 5
				; B -- Size 4
				; U -- Size 3
				; D -- Size 3
				; S -- Size 2

				; The Ships.
 0000025E 11			playerHealth BYTE 17
 0000025F 05			playerCarrierHealth BYTE 5
 00000260 04			playerBattleshipHealth BYTE 4
 00000261 03			playerSubmarineHealth BYTE 3
 00000262 03			playerDestroyerHealth BYTE 3
 00000263 02			playerSweeperHealth BYTE 2


				; Computer's map/grid.
 00000264 23 3A 20 41 7C	ComputerMap BYTE "#: A|B|C|D|E|F|G|H|I|J"
	   42 7C 43 7C 44
	   7C 45 7C 46 7C
	   47 7C 48 7C 49
	   7C 4A
 0000027A  30 3A 20 5F 7C		BYTE "0: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 00000290  31 3A 20 5F 7C		BYTE "1: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 000002A6  32 3A 20 5F 7C		BYTE "2: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 000002BC  33 3A 20 5F 7C		BYTE "3: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 000002D2  34 3A 20 5F 7C		BYTE "4: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 000002E8  35 3A 20 5F 7C		BYTE "5: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 000002FE  36 3A 20 5F 7C		BYTE "6: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 00000314  37 3A 20 5F 7C		BYTE "7: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 0000032A  38 3A 20 5F 7C		BYTE "8: _|_|_|_|_|_|_|_|_|_"
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F
 00000340  39 3A 20 5F 7C		BYTE "9: _|_|_|_|_|_|_|_|_|_",0
	   5F 7C 5F 7C 5F
	   7C 5F 7C 5F 7C
	   5F 7C 5F 7C 5F
	   7C 5F 00
				; computer stuff
 00000357 00			isSunk BYTE 0
				; Computer's ships and health value counters
 00000358 11			compHealth BYTE 17
 00000359 05			compCarrierHealth BYTE 5		
 0000035A 04			compBshipHealth BYTE 4			
 0000035B 03			compSubHealth BYTE 3			
 0000035C 03			compDestroyerHealth BYTE 3		
 0000035D 02			compSweeperHealth BYTE 2
				; Ships arraysm double size 1 byte for row and 1 byte for col
 0000035E  0000000A [		compCarrierArray BYTE 10 DUP (0)
	    00
	   ]
 00000368  00000008 [		compBshipArray BYTE 8 DUP (0)
	    00
	   ]
 00000370  00000006 [		compSubArray BYTE 6 DUP (0)
	    00
	   ]
 00000376  00000006 [		compDestroyerArray BYTE 6 DUP (0)
	    00
	   ]
 0000037C  00000004 [		compSweeperArray BYTE 4 DUP (0)
	    00
	   ]

				; Game mechanic/game state messages.
 00000380 57 65 6C 63 6F	BeginText BYTE "Welcome to BattleShip! Press Enter to begin.", 0
	   6D 65 20 74 6F
	   20 42 61 74 74
	   6C 65 53 68 69
	   70 21 20 50 72
	   65 73 73 20 45
	   6E 74 65 72 20
	   74 6F 20 62 65
	   67 69 6E 2E 00
 000003AD 2D 2D 20 59 4F	PlayerLabel BYTE "-- YOUR BOARD --", 0
	   55 52 20 42 4F
	   41 52 44 20 2D
	   2D 00
 000003BE 2D 2D 20 54 48	ComputerLabel BYTE "-- THE ENEMY --", 0
	   45 20 45 4E 45
	   4D 59 20 2D 2D
	   00
 000003CE 53 68 69 70 20	PlaceTitle BYTE "Ship Placement", 0
	   50 6C 61 63 65
	   6D 65 6E 74 00
 000003DD 54 6F 20 70 6C	PlaceDirection BYTE "To place a ship, click a coordinate on the map", 0
	   61 63 65 20 61
	   20 73 68 69 70
	   2C 20 63 6C 69
	   63 6B 20 61 20
	   63 6F 6F 72 64
	   69 6E 61 74 65
	   20 6F 6E 20 74
	   68 65 20 6D 61
	   70 00
 0000040C 20 4C 65 66 74	PlaceVertical BYTE " Left Click = Vertical", 0
	   20 43 6C 69 63
	   6B 20 3D 20 56
	   65 72 74 69 63
	   61 6C 00
 00000423 20 52 69 67 68	PlaceHorizontal BYTE " Right Click = Horizontal", 0
	   74 20 43 6C 69
	   63 6B 20 3D 20
	   48 6F 72 69 7A
	   6F 6E 74 61 6C
	   00
 0000043D 48 65 61 6C 74	HealthLabel BYTE "Health: ", 0
	   68 3A 20 00
 00000446 53 68 69 70 73	RemainingLabel BYTE "Ships Remaining: ", 0
	   20 52 65 6D 61
	   69 6E 69 6E 67
	   3A 20 00
 00000458 54 68 65 20 63	CompPlacedAll BYTE "The computer is ready!", 0
	   6F 6D 70 75 74
	   65 72 20 69 73
	   20 72 65 61 64
	   79 21 00
				; turn messages
 0000046F 50 6C 61 79 65	playerTurnResult BYTE "Player attack resulted in a ", 0
	   72 20 61 74 74
	   61 63 6B 20 72
	   65 73 75 6C 74
	   65 64 20 69 6E
	   20 61 20 00
 0000048C 43 6F 6D 70 75	computerTurnResult BYTE "Computer attack resulted in a ", 0
	   74 65 72 20 61
	   74 74 61 63 6B
	   20 72 65 73 75
	   6C 74 65 64 20
	   69 6E 20 61 20
	   00
 000004AB 59 6F 75 72 20	pTurnNotice BYTE "Your turn!  Choose a grid coordinate", 0
	   74 75 72 6E 21
	   20 20 43 68 6F
	   6F 73 65 20 61
	   20 67 72 69 64
	   20 63 6F 6F 72
	   64 69 6E 61 74
	   65 00
 000004D0 54 68 65 20 63	cTurnNotice BYTE "The computer is attacking!", 0
	   6F 6D 70 75 74
	   65 72 20 69 73
	   20 61 74 74 61
	   63 6B 69 6E 67
	   21 00
 000004EB 59 6F 75 72 20	pTurnResult BYTE "Your attack resulted in a ", 0
	   61 74 74 61 63
	   6B 20 72 65 73
	   75 6C 74 65 64
	   20 69 6E 20 61
	   20 00
 00000506 43 6F 6D 70 75	cTurnResult BYTE "Computer attack resulted in a ", 0
	   74 65 72 20 61
	   74 74 61 63 6B
	   20 72 65 73 75
	   6C 74 65 64 20
	   69 6E 20 61 20
	   00
 00000525 48 49 54 21 00	hitResult BYTE "HIT!", 0
 0000052A 4D 49 53 53 21	missResult BYTE "MISS!", 0
	   00
				; Types of ships and the spaces they take up.
 00000530 42 61 74 74 6C	BattleshipLabel BYTE "BattleShip (size 4)", 0
	   65 53 68 69 70
	   20 28 73 69 7A
	   65 20 34 29 00
 00000544 43 61 72 72 69	CarrierLabel BYTE "Carrier (size 5)", 0
	   65 72 20 28 73
	   69 7A 65 20 35
	   29 00
 00000555 53 75 62 6D 61	SubmarineLabel BYTE "Submarine (size 3)", 0
	   72 69 6E 65 20
	   28 73 69 7A 65
	   20 33 29 00
 00000568 44 65 74 72 6F	DestroyerLabel BYTE "Detroyer (size 3)", 0
	   79 65 72 20 28
	   73 69 7A 65 20
	   33 29 00
 0000057A 53 77 65 65 70	SweeperLabel BYTE "Sweeper (size 2)", 0
	   65 72 20 28 73
	   69 7A 65 20 32
	   29 00
 0000058B 5B 53 68 69 70	shipToPlace BYTE "[Ship to place]  ", 0
	   20 74 6F 20 70
	   6C 61 63 65 5D
	   20 20 00
				; starting
 0000059D 59 6F 75 72 20	playerPlacementComplete BYTE "Your ships have been placed, now the computer places ships.", 0
	   73 68 69 70 73
	   20 68 61 76 65
	   20 62 65 65 6E
	   20 70 6C 61 63
	   65 64 2C 20 6E
	   6F 77 20 74 68
	   65 20 63 6F 6D
	   70 75 74 65 72
	   20 70 6C 61 63
	   65 73 20 73 68
	   69 70 73 2E 00
 000005D9 54 68 65 20 63	computerPlacementComplete BYTE "The computer is ready!", 0
	   6F 6D 70 75 74
	   65 72 20 69 73
	   20 72 65 61 64
	   79 21 00
 000005F0 41 6C 6C 20 73	allShipsPlaced BYTE "All ships have been placed.", 0
	   68 69 70 73 20
	   68 61 76 65 20
	   62 65 65 6E 20
	   70 6C 61 63 65
	   64 2E 00
				; combat
 0000060C 59 4F 55 20 4C	playerShipSunkMsg BYTE "YOU LOST A SHIP!", 0
	   4F 53 54 20 41
	   20 53 48 49 50
	   21 00
 0000061D 59 4F 55 20 53	computerShipSunkMsg BYTE "YOU SUNK ONE OF THEIR SHIPS!", 0
	   55 4E 4B 20 4F
	   4E 45 20 4F 46
	   20 54 48 45 49
	   52 20 53 48 49
	   50 53 21 00
 0000063A 59 6F 75 20 62	Victory BYTE "You beat him!  Wow!  Awesome that's really amazing considering how buggy ship placement is right now.  Nice job!.", 0
	   65 61 74 20 68
	   69 6D 21 20 20
	   57 6F 77 21 20
	   20 41 77 65 73
	   6F 6D 65 20 74
	   68 61 74 27 73
	   20 72 65 61 6C
	   6C 79 20 61 6D
	   61 7A 69 6E 67
	   20 63 6F 6E 73
	   69 64 65 72 69
	   6E 67 20 68 6F
	   77 20 62 75 67
	   67 79 20 73 68
	   69 70 20 70 6C
	   61 63 65 6D 65
	   6E 74 20 69 73
	   20 72 69 67 68
	   74 20 6E 6F 77
	   2E 20 20 4E 69
	   63 65 20 6A 6F
	   62 21 2E 00
 000006AC 4D 69 73 73 69	Defeat BYTE "Mission Failed, We'll get 'em next time.", 0
	   6F 6E 20 46 61
	   69 6C 65 64 2C
	   20 57 65 27 6C
	   6C 20 67 65 74
	   20 27 65 6D 20
	   6E 65 78 74 20
	   74 69 6D 65 2E
	   00
				; errors
 000006D5 45 72 72 6F 72	PlacementError BYTE "Error: Ships cannot overlap. Please try again.", 0
	   3A 20 53 68 69
	   70 73 20 63 61
	   6E 6E 6F 74 20
	   6F 76 65 72 6C
	   61 70 2E 20 50
	   6C 65 61 73 65
	   20 74 72 79 20
	   61 67 61 69 6E
	   2E 00

				; Macros and Structs
				; writes string at x,y pos
				mWriteAt MACRO X, Y, literal
					mGotoxy X, Y
					mWriteString literal
				ENDM

				; sets the text color
				mSetTextColor MACRO color
					push eax
					mov eax, color
					call SetTextColor
					pop eax
				ENDM

				; insert delay for ui and gameplay stuff
				mPause MACRO timeMs
					push eax
					mov eax, timeMs
					call Delay
					pop eax
				ENDM

				; writes text + '\n'
				mWriteLn MACRO text
					mWriteString text
					call Crlf
				ENDM

				; writes a single char
				mWriteChar MACRO charCode
					push eax
					mov eax, charChode
					call WriteChar
					pop eax
				ENDM

				; Compare ship health to 0
				; NOTE: dont mess with ecx when check ship health
				; returns ecx
				mCheckShip MACRO hp
					.IF hp == 0
						dec ecx
					.ENDIF
				ENDM

				; modify state variable 
				mCheckSunk MACRO shipHp
					.IF shipHp == 0
						mov isSunk, 1
					.ENDIF
				ENDM

				; https://msdn.microsoft.com/en-us/windows/desktop/ms683499
 00000014			_INPUT_RECORD STRUCT
 00000000  0000				EventType WORD ?
 00000002  0000				WORD ?		; padding to align union
					UNION
 00000004  00000000 0000			KeyEvent KEY_EVENT_RECORD <>		; contains KEY_EVENT_RECORD struct
	   0000 0000 0000
	   00000000
						MouseEvent MOUSE_EVENT_RECORD <>	; contains MOUSE_EVENT_RECORD struct
					ENDS
				_INPUT_RECORD ENDS


				; Variables for mouse, winAPI stuff
 00000704 0000			ROW_COORD WORD ?
 00000706 0000			COL_COORD WORD ?
 00000708 00000000		MAP_INDEX DWORD ?
 0000070C 0000 0000		InputRecord _INPUT_RECORD <>
	   00000000 0000
	   0000 0000 0000
	   00000000
 00000720 00000000		ConsoleMode DWORD 0
 00000724 00000000		hStdln DWORD 0
 00000728 00000000		nRead DWORD 0

				; ***************** Code *************************
 00000000			.code
 00000000			main proc	
 00000000  E8 000000AD			call Init
 00000005  E8 000000BE			call Intro
 0000000A  E8 000001DA			call DrawMap
 0000000F  E8 0000039B			call PrintBottomText
 00000014  E8 000004D5			call PlacePlayerShips
 00000019  E8 0000064A			call PlaceComputerShips
 0000001E				GameLoop:
 0000001E  E8 00000173				call PlayerTurn
 00000023  E8 00000A85				call ComputerTurn
						; compare hhealth to 0
 00000028  B8 00000000				mov eax, 0
 0000002D  3A 05 00000358 R			cmp al, compHealth
 00000033  74 4F				je PlayerWin

 00000035  3A 05 0000025E R			cmp al, playerHealth
 0000003B  74 19				je ComputerWin
 0000003D  EB 0E				jmp AnotherTurn

 0000003F					PlayerWin:
 0000003F  E8 FFFFFFFB				call PlayerWin
 00000044  EB 09				jmp GameOver
					
 00000046					ComputerWin:
 00000046  E8 FFFFFFFB				call ComputerWin
 0000004B  EB 02				jmp GameOver
					
 0000004D					AnotherTurn:
 0000004D  EB CF			jmp GameLoop
					
 0000004F				GameOver:
				INVOKE ExitProcess, 0
 0000004F  6A 00	   *	    push   +000000000h
 00000051  E8 00000000 E   *	    call   ExitProcess
 00000056			main endp

				; Computer Wins screen
 00000056			ComputerWin PROC
 00000056  E8 00000000 E		call Clrscr
					mSetTextColor lightRed
 0000005B  50		     1		push eax
 0000005C  B8 0000000C	     1		mov eax, lightRed
 00000061  E8 00000000 E     1		call SetTextColor
 00000066  58		     1		pop eax
					mWriteAt 15, 15, Defeat
 00000067  52		     2		push edx
 00000068  B6 0F	     2		mov  dh,15
 0000006A  B2 0F	     2		mov  dl,15
 0000006C  E8 00000000 E     2		call Gotoxy
 00000071  5A		     2		pop  edx
 00000072  52		     2		push edx
 00000073  BA 000006AC R     2		mov  edx,OFFSET Defeat
 00000078  E8 00000000 E     2		call WriteString
 0000007D  5A		     2		pop  edx
 0000007E  E8 00000000 E		call ReadChar
 00000083  C3				ret
 00000084			ComputerWin ENDP

				; Player Wins screen
 00000084			PlayerWin PROC
 00000084  E8 00000000 E		call Clrscr
					mSetTextColor lightGreen
 00000089  50		     1		push eax
 0000008A  B8 0000000A	     1		mov eax, lightGreen
 0000008F  E8 00000000 E     1		call SetTextColor
 00000094  58		     1		pop eax
					mWriteAt 15, 15, Victory
 00000095  52		     2		push edx
 00000096  B6 0F	     2		mov  dh,15
 00000098  B2 0F	     2		mov  dl,15
 0000009A  E8 00000000 E     2		call Gotoxy
 0000009F  5A		     2		pop  edx
 000000A0  52		     2		push edx
 000000A1  BA 0000063A R     2		mov  edx,OFFSET Victory
 000000A6  E8 00000000 E     2		call WriteString
 000000AB  5A		     2		pop  edx
 000000AC  E8 00000000 E		call ReadChar
 000000B1  C3				ret
 000000B2			PlayerWin ENDP

				; Sets some important values
 000000B2			Init PROC
 000000B2  E8 00000000 E		call Randomize
 000000B7  E8 00000000 E		call GetMaxXY
 000000BC  A2 00000153 R		mov numRows, al
 000000C1  88 15 00000154 R		mov numCols, dl
 000000C7  C3				ret
 000000C8			Init ENDP

				; Introduction screen
				; Displays the rules of the game, waits for user input
 000000C8			Intro PROC
					mSetTextColor lightMagenta
 000000C8  50		     1		push eax
 000000C9  B8 0000000D	     1		mov eax, lightMagenta
 000000CE  E8 00000000 E     1		call SetTextColor
 000000D3  58		     1		pop eax
					mWriteAt 20, 6, intro1
 000000D4  52		     2		push edx
 000000D5  B6 06	     2		mov  dh,6
 000000D7  B2 14	     2		mov  dl,20
 000000D9  E8 00000000 E     2		call Gotoxy
 000000DE  5A		     2		pop  edx
 000000DF  52		     2		push edx
 000000E0  BA 00000000 R     2		mov  edx,OFFSET intro1
 000000E5  E8 00000000 E     2		call WriteString
 000000EA  5A		     2		pop  edx
					mWriteAt 3, 7, intro2

 000000EB  52		     2		push edx
 000000EC  B6 07	     2		mov  dh,7
 000000EE  B2 03	     2		mov  dl,3
 000000F0  E8 00000000 E     2		call Gotoxy
 000000F5  5A		     2		pop  edx
 000000F6  52		     2		push edx
 000000F7  BA 00000019 R     2		mov  edx,OFFSET intro2
 000000FC  E8 00000000 E     2		call WriteString
 00000101  5A		     2		pop  edx
					mWriteAt 3, 8, intro3
 00000102  52		     2		push edx
 00000103  B6 08	     2		mov  dh,8
 00000105  B2 03	     2		mov  dl,3
 00000107  E8 00000000 E     2		call Gotoxy
 0000010C  5A		     2		pop  edx
 0000010D  52		     2		push edx
 0000010E  BA 00000029 R     2		mov  edx,OFFSET intro3
 00000113  E8 00000000 E     2		call WriteString
 00000118  5A		     2		pop  edx
					mWriteAt 3, 8, intro4
 00000119  52		     2		push edx
 0000011A  B6 08	     2		mov  dh,8
 0000011C  B2 03	     2		mov  dl,3
 0000011E  E8 00000000 E     2		call Gotoxy
 00000123  5A		     2		pop  edx
 00000124  52		     2		push edx
 00000125  BA 00000077 R     2		mov  edx,OFFSET intro4
 0000012A  E8 00000000 E     2		call WriteString
 0000012F  5A		     2		pop  edx
					mWriteAt 3, 9, intro5
 00000130  52		     2		push edx
 00000131  B6 09	     2		mov  dh,9
 00000133  B2 03	     2		mov  dl,3
 00000135  E8 00000000 E     2		call Gotoxy
 0000013A  5A		     2		pop  edx
 0000013B  52		     2		push edx
 0000013C  BA 000000A2 R     2		mov  edx,OFFSET intro5
 00000141  E8 00000000 E     2		call WriteString
 00000146  5A		     2		pop  edx
					mWriteAt 3, 10, intro6
 00000147  52		     2		push edx
 00000148  B6 0A	     2		mov  dh,10
 0000014A  B2 03	     2		mov  dl,3
 0000014C  E8 00000000 E     2		call Gotoxy
 00000151  5A		     2		pop  edx
 00000152  52		     2		push edx
 00000153  BA 000000F9 R     2		mov  edx,OFFSET intro6
 00000158  E8 00000000 E     2		call WriteString
 0000015D  5A		     2		pop  edx
 0000015E  E8 00000000 E		call Crlf
 00000163  E8 00000000 E		call Crlf
					mWriteAt 3, 11, intro7
 00000168  52		     2		push edx
 00000169  B6 0B	     2		mov  dh,11
 0000016B  B2 03	     2		mov  dl,3
 0000016D  E8 00000000 E     2		call Gotoxy
 00000172  5A		     2		pop  edx
 00000173  52		     2		push edx
 00000174  BA 00000134 R     2		mov  edx,OFFSET intro7
 00000179  E8 00000000 E     2		call WriteString
 0000017E  5A		     2		pop  edx

					;call WaitMsg
					
					mSetTextColor white
 0000017F  50		     1		push eax
 00000180  B8 0000000F	     1		mov eax, white
 00000185  E8 00000000 E     1		call SetTextColor
 0000018A  58		     1		pop eax
 0000018B  E8 00000000 E		call ReadChar
 00000190  E8 00000000 E		call Clrscr
 00000195  C3				ret ; dont forget ret, or youll spend an hour debugging nothing
 00000196			Intro ENDP

				; Notifies player turn, waits for mouse click
 00000196			PlayerTurn PROC
 00000196  E8 00000BAC			call ClearDirections
					
					mWriteAt 20, 23, pTurnNotice
 0000019B  52		     2		push edx
 0000019C  B6 17	     2		mov  dh,23
 0000019E  B2 14	     2		mov  dl,20
 000001A0  E8 00000000 E     2		call Gotoxy
 000001A5  5A		     2		pop  edx
 000001A6  52		     2		push edx
 000001A7  BA 000004AB R     2		mov  edx,OFFSET pTurnNotice
 000001AC  E8 00000000 E     2		call WriteString
 000001B1  5A		     2		pop  edx

					mPause 1000
 000001B2  50		     1		push eax
 000001B3  B8 000003E8	     1		mov eax, 1000
 000001B8  E8 00000000 E     1		call Delay
 000001BD  58		     1		pop eax
					; get mouse info
 000001BE  E8 00000E67			call GetMouseLoc
 000001C3  E8 00000F4B			call ConvertRowCoord
 000001C8  E8 00000F6E			call ConvertColCoord

 000001CD  E8 000005BC			call CheckAttkPlayer
					; redraw map
 000001D2  E8 00000012			call DrawMap
 000001D7  E8 000001D3			call PrintBottomText
					mPause 1000
 000001DC  50		     1		push eax
 000001DD  B8 000003E8	     1		mov eax, 1000
 000001E2  E8 00000000 E     1		call Delay
 000001E7  58		     1		pop eax
 000001E8  C3				ret
 000001E9			PlayerTurn ENDP

				; Generates a player and computer grid/board.
				; map is redrawn after each ship placed & each turn
 000001E9			DrawMap PROC
 000001E9  BE 00000000			mov esi, 0
 000001EE  BE 0000016B R		mov esi, OFFSET PlayerMap ; esi points to start of the player board array

					mGotoxy 20, 5		; initial cursor psition
 000001F3  52		     1		push edx
 000001F4  B6 05	     1		mov  dh,5
 000001F6  B2 14	     1		mov  dl,20
 000001F8  E8 00000000 E     1		call Gotoxy
 000001FD  5A		     1		pop  edx
					mSetTextColor cyan	; player board color
 000001FE  50		     1		push eax
 000001FF  B8 00000003	     1		mov eax, cyan
 00000204  E8 00000000 E     1		call SetTextColor
 00000209  58		     1		pop eax

					; Prints the A-F header
 0000020A  B9 00000016			mov ecx, 22
 0000020F				PrintTopRow:
 0000020F  8B 06				mov eax, [esi]
 00000211  E8 00000000 E			call WriteChar
 00000216  46					inc esi
 00000217  E2 F6			loop PrintTopRow

 00000219  B2 14			mov dl, 20		; ROW ---> save this value
 0000021B  B6 06			mov dh, 6		; COL ---> save this value
 0000021D  E8 00000000 E		call GoToXY
					;mGotoxy 10, 6

 00000222  B9 0000000A			mov ecx, 10
 00000227				CreatePlayerMap:
 00000227  51					push ecx			; save ecx for later (10 playable squares)
 00000228  B9 00000016				mov ecx, 22			; use 22 for total squares

 0000022D					ChooseChar:
 0000022D  8A 06				mov al, [esi]	; use the contents of esi to check what to draw
 0000022F  3C 4F				cmp al, 'O'		; Compare to 'O'
 00000231  75 1B				jne CheckPlayerHit
						mSetTextColor white
 00000233  50		     1		push eax
 00000234  B8 0000000F	     1		mov eax, white
 00000239  E8 00000000 E     1		call SetTextColor
 0000023E  58		     1		pop eax
 0000023F  B8 0000004F				mov eax, 'O'		; Write 'O'
 00000244  E8 00000000 E			call WriteChar
 00000249  E9 000000B2				jmp PlayerCharPlaced

 0000024E					CheckPlayerHit:
 0000024E  3C 58				cmp al, 'X'			; Compare to 'X'
 00000250  75 19				jne CheckCarrier
 00000252  B8 0000000C				mov eax, lightRed	; then it's a hit
 00000257  E8 00000000 E			call SetTextColor
 0000025C  B8 00000058				mov eax, 'X'
 00000261  E8 00000000 E			call WriteChar
 00000266  E9 00000095				jmp PlayerCharPlaced

						; Compare to 'C' then it's a carrier
 0000026B					CheckCarrier:
 0000026B  3C 43				cmp al, 'C'
 0000026D  75 16				jne CheckBattleship
 0000026F  B8 0000001F				mov eax, white + (blue * 16)
 00000274  E8 00000000 E			call SetTextColor
 00000279  B8 00000043				mov eax, 'C'
 0000027E  E8 00000000 E			call WriteChar
 00000283  EB 7B				jmp PlayerCharPlaced

						; Compare to 'B' for b-ship
 00000285					CheckBattleship:
 00000285  3C 42				cmp al, 'B'
 00000287  75 16				jne CheckSubmarine
 00000289  B8 0000001F				mov eax, white + (blue * 16)
 0000028E  E8 00000000 E			call SetTextColor
 00000293  B8 00000042				mov eax, 'B'
 00000298  E8 00000000 E			call WriteChar
 0000029D  EB 61				jmp PlayerCharPlaced

						; compare al to 'U'
 0000029F					CheckSubmarine:
 0000029F  3C 55				cmp al, 'U'
 000002A1  75 16				jne CheckDestroyer
 000002A3  B8 0000001F				mov eax, white + (blue * 16)
 000002A8  E8 00000000 E			call SetTextColor
 000002AD  B8 00000055				mov eax, 'U'
 000002B2  E8 00000000 E			call WriteChar
 000002B7  EB 47				jmp PlayerCharPlaced

						; cmp al to 'D'
 000002B9					CheckDestroyer:
 000002B9  3C 44				cmp al, 'D'
 000002BB  75 16				jne CheckSweeper
 000002BD  B8 0000001F				mov eax, white + (blue * 16)
 000002C2  E8 00000000 E			call SetTextColor
 000002C7  B8 00000044				mov eax, 'D'
 000002CC  E8 00000000 E			call WriteChar
 000002D1  EB 2D				jmp PlayerCharPlaced
						
						; compare al to "S'
 000002D3					CheckSweeper:
 000002D3  3C 53				cmp al, 'S'
 000002D5  75 16				jne PrintPlayerMapCharacter
 000002D7  B8 0000001F				mov eax, white + (blue * 16)
 000002DC  E8 00000000 E			call SetTextColor
 000002E1  B8 00000053				mov eax, 'S'
 000002E6  E8 00000000 E			call WriteChar
 000002EB  EB 13				jmp PlayerCharPlaced

						; if none of above then write contents of esi
 000002ED					PrintPlayerMapCharacter:
						mSetTextColor cyan
 000002ED  50		     1		push eax
 000002EE  B8 00000003	     1		mov eax, cyan
 000002F3  E8 00000000 E     1		call SetTextColor
 000002F8  58		     1		pop eax
 000002F9  8B 06				mov eax, [esi]
 000002FB  E8 00000000 E			call WriteChar

						; jmp here if above condition succeeds
 00000300					PlayerCharPlaced:
 00000300  46					inc esi
 00000301  83 F9 00				cmp ecx, 0	; loop from 10 --> 0
 00000304  74 07				je PlayerRowComplete
 00000306  49					dec ecx
 00000307  0F 85 FFFFFF20			jne ChooseChar

 0000030D				PlayerRowComplete:
 0000030D  59				pop ecx		; Restore ecx = 22
 0000030E  FE C6			inc dh		; Next row (for gotoxy)
 00000310  E8 00000000 E		call GoToXY
					;call Crlf

 00000315  83 F9 00			cmp ecx, 0
 00000318  49				dec ecx
 00000319  0F 85 FFFFFF08		jne CreatePlayerMap

					; ************* Computer map ****************
 0000031F  BF 00000000			mov edi, 0
 00000324  BF 00000264 R		mov edi, OFFSET ComputerMap ; edi points to the viewable computer board

 00000329  B2 3C			mov dl, 60
 0000032B  B6 05			mov dh, 5
 0000032D  E8 00000000 E		call GoToXY
					mGotoxy 60, 5
 00000332  52		     1		push edx
 00000333  B6 05	     1		mov  dh,5
 00000335  B2 3C	     1		mov  dl,60
 00000337  E8 00000000 E     1		call Gotoxy
 0000033C  5A		     1		pop  edx

 0000033D  B9 0000000B			mov ecx, 11		; Outer loop counter = 11
 00000342				CreateComputerBoard:
						; save ecx
 00000342  51					push ecx	; inner loop counter = 22
 00000343  B9 00000016				mov ecx, 22
 00000348					PrintComputerRow:
 00000348  8A 07				mov al, [edi]
						; Missed Character 'O'
 0000034A  3C 4F				cmp al, 'O'
 0000034C  75 18				jne CheckComputerHit
						mSetTextColor white
 0000034E  50		     1		push eax
 0000034F  B8 0000000F	     1		mov eax, white
 00000354  E8 00000000 E     1		call SetTextColor
 00000359  58		     1		pop eax
 0000035A  B8 0000004F				mov eax, 'O'
 0000035F  E8 00000000 E			call WriteChar
 00000364  EB 2F				jmp CompCharPlaced

						; check for 'X'
 00000366					CheckComputerHit:
 00000366  3C 58				cmp al, 'X'
 00000368  75 18				jne PrintComputerMapCharacter
						mSetTextColor lightRed
 0000036A  50		     1		push eax
 0000036B  B8 0000000C	     1		mov eax, lightRed
 00000370  E8 00000000 E     1		call SetTextColor
 00000375  58		     1		pop eax
 00000376  B8 00000058				mov eax, 'X'
 0000037B  E8 00000000 E			call WriteChar
 00000380  EB 13				jmp CompCharPlaced

						; otw just printchar from array (hidden from player view)
 00000382					PrintComputerMapCharacter:
						mSetTextColor yellow
 00000382  50		     1		push eax
 00000383  B8 0000000E	     1		mov eax, yellow
 00000388  E8 00000000 E     1		call SetTextColor
 0000038D  58		     1		pop eax
 0000038E  8B 07				mov eax, [edi]
 00000390  E8 00000000 E			call WriteChar

 00000395					CompCharPlaced:
 00000395  47					inc edi
 00000396  E2 B0				loop PrintComputerRow
 00000398  59					pop ecx		; restore ecx after inner loop
 00000399  FE C6				inc dh		; Next row
 0000039B  E8 00000000 E			call GoToXY
						;call Crlf
 000003A0  E2 A0			loop CreateComputerBoard
					mSetTextColor white
 000003A2  50		     1		push eax
 000003A3  B8 0000000F	     1		mov eax, white
 000003A8  E8 00000000 E     1		call SetTextColor
 000003AD  58		     1		pop eax
 000003AE  C3				ret
 000003AF			DrawMap ENDP


				; Print UI Info/Stats --- Gets printed below the boards
				; Health & num ships remaining
 000003AF			PrintBottomText PROC
					; top of board labels
					mWriteAt 22, 3, PlayerLabel
 000003AF  52		     2		push edx
 000003B0  B6 03	     2		mov  dh,3
 000003B2  B2 16	     2		mov  dl,22
 000003B4  E8 00000000 E     2		call Gotoxy
 000003B9  5A		     2		pop  edx
 000003BA  52		     2		push edx
 000003BB  BA 000003AD R     2		mov  edx,OFFSET PlayerLabel
 000003C0  E8 00000000 E     2		call WriteString
 000003C5  5A		     2		pop  edx
					mWriteAt 66, 3, ComputerLabel
 000003C6  52		     2		push edx
 000003C7  B6 03	     2		mov  dh,3
 000003C9  B2 42	     2		mov  dl,66
 000003CB  E8 00000000 E     2		call Gotoxy
 000003D0  5A		     2		pop  edx
 000003D1  52		     2		push edx
 000003D2  BA 000003BE R     2		mov  edx,OFFSET ComputerLabel
 000003D7  E8 00000000 E     2		call WriteString
 000003DC  5A		     2		pop  edx

					; player health
					mWriteAt 20, 19, HealthLabel	
 000003DD  52		     2		push edx
 000003DE  B6 13	     2		mov  dh,19
 000003E0  B2 14	     2		mov  dl,20
 000003E2  E8 00000000 E     2		call Gotoxy
 000003E7  5A		     2		pop  edx
 000003E8  52		     2		push edx
 000003E9  BA 0000043D R     2		mov  edx,OFFSET HealthLabel
 000003EE  E8 00000000 E     2		call WriteString
 000003F3  5A		     2		pop  edx
 000003F4  0F B6 05			movzx eax, playerHealth
	   0000025E R
 000003FB  E8 00000000 E		call WriteInt

					; computer health
					mWriteAt 60, 19, HealthLabel
 00000400  52		     2		push edx
 00000401  B6 13	     2		mov  dh,19
 00000403  B2 3C	     2		mov  dl,60
 00000405  E8 00000000 E     2		call Gotoxy
 0000040A  5A		     2		pop  edx
 0000040B  52		     2		push edx
 0000040C  BA 0000043D R     2		mov  edx,OFFSET HealthLabel
 00000411  E8 00000000 E     2		call WriteString
 00000416  5A		     2		pop  edx
 00000417  0F B6 05			movzx eax, compHealth
	   00000358 R
 0000041E  E8 00000000 E		call WriteInt

					; player ships remaining msg
					mWriteAt 20, 20, RemainingLabel
 00000423  52		     2		push edx
 00000424  B6 14	     2		mov  dh,20
 00000426  B2 14	     2		mov  dl,20
 00000428  E8 00000000 E     2		call Gotoxy
 0000042D  5A		     2		pop  edx
 0000042E  52		     2		push edx
 0000042F  BA 00000446 R     2		mov  edx,OFFSET RemainingLabel
 00000434  E8 00000000 E     2		call WriteString
 00000439  5A		     2		pop  edx
 0000043A  E8 00000030			call CalcShipsRemaining	; al=player count bl=comp count
 0000043F  E8 00000000 E		call WriteDec

					; computer ships remaining msg
					mWriteAt 60, 20, RemainingLabel
 00000444  52		     2		push edx
 00000445  B6 14	     2		mov  dh,20
 00000447  B2 3C	     2		mov  dl,60
 00000449  E8 00000000 E     2		call Gotoxy
 0000044E  5A		     2		pop  edx
 0000044F  52		     2		push edx
 00000450  BA 00000446 R     2		mov  edx,OFFSET RemainingLabel
 00000455  E8 00000000 E     2		call WriteString
 0000045A  5A		     2		pop  edx
 0000045B  8A C3			mov al, bl
 0000045D  E8 00000000 E		call WriteDec
					
					mSetTextColor white
 00000462  50		     1		push eax
 00000463  B8 0000000F	     1		mov eax, white
 00000468  E8 00000000 E     1		call SetTextColor
 0000046D  58		     1		pop eax
 0000046E  C3				ret
 0000046F			PrintBottomText ENDP

				; Compares ship health variables to 0
				; sinks player ships at 0
				; returns	eax: player ships remaining
				;			ebx: comp ships remaining
 0000046F			CalcShipsRemaining PROC USES ecx
 0000046F  51		   *	    push   ecx
 00000470  B8 00000000			mov eax, 0
 00000475  BB 00000000			mov ebx, 0
 0000047A  B9 00000005			mov ecx, 5		; num ships
					; c gets decremented for each missing
					mCheckShip playerCarrierHealth
 0000047F  80 3D 0000025F R
	   00		   *	    cmp    playerCarrierHealth, 000h
 00000486  75 01	   *	    jne    @C0001
 00000488  49		     1			dec ecx
 00000489		   *@C0001:
					mCheckShip playerBattleshipHealth
 00000489  80 3D 00000260 R
	   00		   *	    cmp    playerBattleshipHealth, 000h
 00000490  75 01	   *	    jne    @C0003
 00000492  49		     1			dec ecx
 00000493		   *@C0003:
					mCheckShip playerSubmarineHealth
 00000493  80 3D 00000261 R
	   00		   *	    cmp    playerSubmarineHealth, 000h
 0000049A  75 01	   *	    jne    @C0005
 0000049C  49		     1			dec ecx
 0000049D		   *@C0005:
					mCheckShip playerDestroyerHealth
 0000049D  80 3D 00000262 R
	   00		   *	    cmp    playerDestroyerHealth, 000h
 000004A4  75 01	   *	    jne    @C0007
 000004A6  49		     1			dec ecx
 000004A7		   *@C0007:
					mCheckShip playerSweeperHealth
 000004A7  80 3D 00000263 R
	   00		   *	    cmp    playerSweeperHealth, 000h
 000004AE  75 01	   *	    jne    @C0009
 000004B0  49		     1			dec ecx
 000004B1		   *@C0009:
 000004B1  8B C1			mov eax, ecx

 000004B3  B9 00000005			mov ecx, 5
					mCheckShip compCarrierHealth
 000004B8  80 3D 00000359 R
	   00		   *	    cmp    compCarrierHealth, 000h
 000004BF  75 01	   *	    jne    @C000B
 000004C1  49		     1			dec ecx
 000004C2		   *@C000B:
					mCheckShip compBshipHealth
 000004C2  80 3D 0000035A R
	   00		   *	    cmp    compBshipHealth, 000h
 000004C9  75 01	   *	    jne    @C000D
 000004CB  49		     1			dec ecx
 000004CC		   *@C000D:
					mCheckShip compSubHealth
 000004CC  80 3D 0000035B R
	   00		   *	    cmp    compSubHealth, 000h
 000004D3  75 01	   *	    jne    @C000F
 000004D5  49		     1			dec ecx
 000004D6		   *@C000F:
					mCheckShip compDestroyerHealth
 000004D6  80 3D 0000035C R
	   00		   *	    cmp    compDestroyerHealth, 000h
 000004DD  75 01	   *	    jne    @C0011
 000004DF  49		     1			dec ecx
 000004E0		   *@C0011:
					mCheckShip compSweeperHealth
 000004E0  80 3D 0000035D R
	   00		   *	    cmp    compSweeperHealth, 000h
 000004E7  75 01	   *	    jne    @C0013
 000004E9  49		     1			dec ecx
 000004EA		   *@C0013:
 000004EA  8B D9			mov ebx, ecx
					ret
 000004EC  59		   *	    pop    ecx
 000004ED  C3		   *	    ret    00000h
 000004EE			CalcShipsRemaining ENDP


				; ***********************************************************************************
				;		Ship Placement
				; ***********************************************************************************


				; Places all the player ships on the map. Each ship is placed using separate procedures.
				; Displays proper directions to the player.
				; TODO: A lot of repetitive code here, may be able to simplify
				;	A single method and pass the ship as a param?
 000004EE			PlacePlayerShips PROC
 000004EE  B8 00000000			mov eax, 0
 000004F3  BB 00000000			mov ebx, 0
 000004F8  E8 00000AFC			call PrintShipInstructions
					mWriteString CarrierLabel
 000004FD  52		     1		push edx
 000004FE  BA 00000544 R     1		mov  edx,OFFSET CarrierLabel
 00000503  E8 00000000 E     1		call WriteString
 00000508  5A		     1		pop  edx
					
					; carrier
 00000509  C6 05 00000157 R		mov currShipSize, 5	; length of ship
	   05
 00000510  C6 05 00000158 R		mov currShipChar, 'C'
	   43
 00000517  E8 000000D2			call PlaceShip
 0000051C  E8 00000826			call ClearDirections

					; b-ship
 00000521  E8 00000AD3			call PrintShipInstructions
					mWriteString BattleshipLabel
 00000526  52		     1		push edx
 00000527  BA 00000530 R     1		mov  edx,OFFSET BattleshipLabel
 0000052C  E8 00000000 E     1		call WriteString
 00000531  5A		     1		pop  edx
 00000532  C6 05 00000157 R		mov currShipSize, 4
	   04
 00000539  C6 05 00000158 R		mov currShipChar, 'B'
	   42
 00000540  E8 000000A9			call PlaceShip
 00000545  E8 000007FD			call ClearDirections

					; sub
 0000054A  E8 00000AAA			call PrintShipInstructions
					mWriteString SubmarineLabel
 0000054F  52		     1		push edx
 00000550  BA 00000555 R     1		mov  edx,OFFSET SubmarineLabel
 00000555  E8 00000000 E     1		call WriteString
 0000055A  5A		     1		pop  edx
 0000055B  C6 05 00000157 R		mov currShipSize, 3
	   03
 00000562  C6 05 00000158 R		mov currShipChar, 'U'
	   55
 00000569  E8 00000080			call PlaceShip
 0000056E  E8 000007D4			call ClearDirections

					; destroyer
 00000573  E8 00000A81			call PrintShipInstructions
					mWriteString DestroyerLabel
 00000578  52		     1		push edx
 00000579  BA 00000568 R     1		mov  edx,OFFSET DestroyerLabel
 0000057E  E8 00000000 E     1		call WriteString
 00000583  5A		     1		pop  edx
 00000584  C6 05 00000157 R		mov currShipSize, 3
	   03
 0000058B  C6 05 00000158 R		mov currShipChar, 'D'
	   44
 00000592  E8 00000057			call PlaceShip
 00000597  E8 000007AB			call ClearDirections
					
					; sweeper
 0000059C  E8 00000A58			call PrintShipInstructions
					mWriteString SweeperLabel
 000005A1  52		     1		push edx
 000005A2  BA 0000057A R     1		mov  edx,OFFSET SweeperLabel
 000005A7  E8 00000000 E     1		call WriteString
 000005AC  5A		     1		pop  edx
 000005AD  C6 05 00000157 R		mov currShipSize, 2
	   02
 000005B4  C6 05 00000158 R		mov currShipChar, 'S'
	   53
 000005BB  E8 0000002E			call PlaceShip
 000005C0  E8 00000782			call ClearDirections

					;AllShipsPlaced
					mGotoxy 20, 23
 000005C5  52		     1		push edx
 000005C6  B6 17	     1		mov  dh,23
 000005C8  B2 14	     1		mov  dl,20
 000005CA  E8 00000000 E     1		call Gotoxy
 000005CF  5A		     1		pop  edx
					mWriteString playerPlacementComplete
 000005D0  52		     1		push edx
 000005D1  BA 0000059D R     1		mov  edx,OFFSET playerPlacementComplete
 000005D6  E8 00000000 E     1		call WriteString
 000005DB  5A		     1		pop  edx
					mPause 3000
 000005DC  50		     1		push eax
 000005DD  B8 00000BB8	     1		mov eax, 3000
 000005E2  E8 00000000 E     1		call Delay
 000005E7  58		     1		pop eax

 000005E8  E8 0000075A			call ClearDirections
 000005ED  C3				ret
 000005EE			PlacePlayerShips ENDP

				; Places a ship on the map based off user click
				; Left click --> place vertical
				; Right click --> horizontal
				; TODO: fix collision detection
 000005EE			PlaceShip PROC
 000005EE			RetryThis:	; restart on error	
 000005EE  E8 00000A37			call GetMouseLoc	;store 1 or 2 in mouesNum
 000005F3  E8 00000B1B			call ConvertRowCoord
 000005F8  E8 00000B3E			call ConvertColCoord

 000005FD  BF 0000016B R		mov edi, OFFSET PlayerMap
 00000602  03 3D 00000708 R		add edi, MAP_INDEX

 00000608  80 3D 00000156 R		cmp mouseNum, 1	; Left click
	   01
 0000060F  74 09			je ItsVertical

 00000611  80 3D 00000156 R		cmp mouseNum, 2	; right click
	   02
 00000618  74 1A			je ItsHorizontal

					; vertical
 0000061A				ItsVertical:	
					;call DetectVertical
 0000061A  83 FA 00			cmp edx, 0
 0000061D  74 CF			je RetryThis
 0000061F  0F B6 0D			movzx ecx, currShipSize
	   00000157 R
 00000626  A0 00000158 R		mov al, currShipChar
 0000062B				Luigi:
 0000062B  88 07				mov [edi], al
 0000062D  83 C7 16				add edi, 22
 00000630  E2 F9			loop Luigi

 00000632  EB 18			jmp BonVoyage

					; horizontal
 00000634				ItsHorizontal:
					;call DetectHorizontal
 00000634  83 FA 00			cmp edx, 0
 00000637  74 B5			je RetryThis
 00000639  0F B6 0D			movzx ecx, currShipSize
	   00000157 R
 00000640  A0 00000158 R		mov al, currShipChar
 00000645				Mario:
 00000645  88 07				mov [edi], al
 00000647  83 C7 02				add edi, 2
 0000064A  E2 F9			loop Mario

					; ships placed
 0000064C				BonVoyage:
 0000064C  B8 00000000			mov eax, 0
 00000651  A0 00000155 R		mov al, ShipsPlaced
 00000656  FE C0			inc al
 00000658  A2 00000155 R		mov ShipsPlaced, al

 0000065D  E8 FFFFFB87			call DrawMap
 00000662  E8 FFFFFD48			call PrintBottomText
 00000667  C3				ret
 00000668			PlaceShip ENDP

				; Main function to place each ship
				; saves current values and calls PlaceCompShip
 00000668			PlaceComputerShips PROC
 00000668  BE 0000035E R		mov esi, OFFSET compCarrierArray
 0000066D  0F B6 0D			movzx ecx, compCarrierHealth
	   00000359 R
 00000674  88 0D 00000159 R		mov currShipHealth, cl	; save it
 0000067A  89 35 0000015B R		mov currOffset, esi
 00000680  E8 0000009D			call PlaceCompShip

 00000685  BE 00000368 R		mov esi, OFFSET compBshipArray
 0000068A  0F B6 0D			movzx ecx, compBshipHealth
	   0000035A R
 00000691  88 0D 00000159 R		mov currShipHealth, cl	; save it
 00000697  89 35 0000015B R		mov currOffset, esi
 0000069D  E8 00000080			call PlaceCompShip

 000006A2  BE 00000370 R		mov esi, OFFSET compSubArray
 000006A7  0F B6 0D			movzx ecx, compSubHealth
	   0000035B R
 000006AE  88 0D 00000159 R		mov currShipHealth, cl	; save it
 000006B4  89 35 0000015B R		mov currOffset, esi
 000006BA  E8 00000063			call PlaceCompShip

 000006BF  BE 00000376 R		mov esi, OFFSET compDestroyerArray
 000006C4  0F B6 0D			movzx ecx, compDestroyerHealth
	   0000035C R
 000006CB  88 0D 00000159 R		mov currShipHealth, cl	; save it
 000006D1  89 35 0000015B R		mov currOffset, esi
 000006D7  E8 00000046			call PlaceCompShip

 000006DC  BE 0000037C R		mov esi, OFFSET compSweeperArray
 000006E1  0F B6 0D			movzx ecx, compSweeperHealth
	   0000035D R
 000006E8  88 0D 00000159 R		mov currShipHealth, cl	; save it
 000006EE  89 35 0000015B R		mov currOffset, esi
 000006F4  E8 00000029			call PlaceCompShip

					; all done
					mWriteAt 20, 23, computerPlacementComplete
 000006F9  52		     2		push edx
 000006FA  B6 17	     2		mov  dh,23
 000006FC  B2 14	     2		mov  dl,20
 000006FE  E8 00000000 E     2		call Gotoxy
 00000703  5A		     2		pop  edx
 00000704  52		     2		push edx
 00000705  BA 000005D9 R     2		mov  edx,OFFSET computerPlacementComplete
 0000070A  E8 00000000 E     2		call WriteString
 0000070F  5A		     2		pop  edx
					mPause 3000
 00000710  50		     1		push eax
 00000711  B8 00000BB8	     1		mov eax, 3000
 00000716  E8 00000000 E     1		call Delay
 0000071B  58		     1		pop eax
 0000071C  E8 00000626			call ClearDirections
 00000721  C3				ret
 00000722			PlaceComputerShips ENDP

				; generic place ship proc
				; Recieves: currShipSize and currOffset
				; Returns: Arrays filled with valid coordinates
 00000722			PlaceCompShip PROC
 00000722			RetryThis:		; restart on error
 00000722  C7 05 00000738 R		mov lowerBound, 1
	   00000001
 0000072C  C7 05 00000734 R		mov upperBound, 2
	   00000002
 00000736  E8 000006C5			call BoundedRandomNum
 0000073B  3C 01			cmp al, 1
 0000073D  74 1B			je  RandV

					; horizontal
 0000073F  8B 35 0000015B R		mov esi, currOffset
 00000745  46				inc esi
 00000746  E8 000006FE			call GetCoordsH	; start position
 0000074B  0F B6 0D			movzx ecx, currShipHealth
	   00000159 R
 00000752  49				dec ecx
 00000753  E8 000007B7			call FillArrayH	; rest of array
 00000758  EB 18			jmp CheckColl

 0000075A				RandV:
 0000075A  8B 35 0000015B R		mov esi, currOffset
 00000760  E8 0000073D			call GetCoordsV	; start
 00000765  0F B6 0D			movzx ecx, currShipHealth
	   00000159 R
 0000076C  49				dec ecx
 0000076D  E8 00000784			call FillArrayV	; rest of it

 00000772				CheckColl:
 00000772  8B 35 0000015B R		mov esi, currOffset
 00000778  0F B6 0D			movzx ecx, currShipHealth
	   00000159 R
 0000077F  E8 000007A5			call CheckRandomCollision
 00000784  80 3D 00000160 R		cmp intersect, 1
	   01
 0000078B  75 95			jne RetryThis

 0000078D  C3				ret
 0000078E			PlaceCompShip ENDP


				; ***********************************************************************************
				;		Hit/Miss Detection
				; ***********************************************************************************

				; compares mouse coords to ship locations
 0000078E			CheckAttkPlayer PROC
 0000078E  C6 05 0000015F R		mov hitBool, 0
	   00
					;mov esi, OFFSET compCarrierArray
 00000795  C7 05 0000015B R		mov currOffset, OFFSET compCarrierArray
	   0000035E R
 0000079F  0F B6 0D			movzx ecx, compCarrierHealth
	   00000359 R
 000007A6  88 0D 00000159 R		mov currShipHealth, cl		; save for proc call
 000007AC  C6 05 00000157 R		mov currShipSize, 5
	   05
 000007B3  E8 0000010A			call ConfirmRowCols
 000007B8  0F B6 0D			movzx ecx, currShipHealth		; updated health
	   00000159 R
 000007BF  88 0D 00000359 R		mov compCarrierHealth, cl
 000007C5  80 3D 0000015F R		cmp hitBool, 1
	   01
 000007CC  0F 84 000000EF		je YouGotEm
					; else check nxt ship

					; battleship
					;mov esi, OFFSET compBshipArray	
 000007D2  C7 05 0000015B R		mov currOffset, OFFSET compBshipArray
	   00000368 R
 000007DC  0F B6 0D			movzx ecx, compBshipHealth
	   0000035A R
 000007E3  88 0D 00000159 R		mov currShipHealth, cl
 000007E9  C6 05 00000157 R		mov currShipSize, 4
	   04
 000007F0  E8 000000CD			call ConfirmRowCols
 000007F5  0F B6 0D			movzx ecx, currShipHealth
	   00000159 R
 000007FC  88 0D 0000035A R		mov compBshipHealth, cl
 00000802  80 3D 0000015F R		cmp hitBool, 1
	   01
 00000809  0F 84 000000B2		je YouGotEm

					; destroyer
					;mov esi, OFFSET compDestroyerArray	
 0000080F  C7 05 0000015B R		mov currOffset, OFFSET compDestroyerArray
	   00000376 R
 00000819  0F B6 0D			movzx ecx, compDestroyerHealth
	   0000035C R
 00000820  88 0D 00000159 R		mov currShipHealth, cl
					;mov ecx, 3
 00000826  C6 05 00000157 R		mov currShipSize, 3
	   03
 0000082D  E8 00000090			call ConfirmRowCols
 00000832  0F B6 0D			movzx ecx, currShipHealth
	   00000159 R
 00000839  88 0D 0000035C R		mov compDestroyerHealth, cl
 0000083F  80 3D 0000015F R		cmp hitBool, 1
	   01
 00000846  74 79			je YouGotEm

					; submarine
					;mov esi, OFFSET compSubArray	
 00000848  C7 05 0000015B R		mov currOffset, OFFSET compSubArray
	   00000370 R
 00000852  0F B6 0D			movzx ecx, compSubHealth
	   0000035B R
 00000859  88 0D 00000159 R		mov currShipHealth, cl
					;mov ecx, 3
 0000085F  C6 05 00000157 R		mov currShipSize, 3
	   03
 00000866  E8 00000057			call ConfirmRowCols
 0000086B  0F B6 0D			movzx ecx, currShipHealth
	   00000159 R
 00000872  88 0D 0000035B R		mov compSubHealth, cl
 00000878  80 3D 0000015F R		cmp hitBool, 1
	   01
 0000087F  74 40			je YouGotEm

					; sweeperino
					;mov esi, OFFSET compSweeperArray
 00000881  C7 05 0000015B R		mov currOffset, OFFSET compSweeperArray
	   0000037C R
 0000088B  0F B6 0D			movzx ecx, compSweeperHealth
	   0000035D R
 00000892  88 0D 00000159 R		mov currShipHealth, cl
					;mov ecx, 2
 00000898  C6 05 00000157 R		mov currShipSize, 2
	   02
 0000089F  E8 0000001E			call ConfirmRowCols
 000008A4  0F B6 0D			movzx ecx, currShipHealth
	   00000159 R
 000008AB  88 0D 0000035D R		mov compSweeperHealth, cl
 000008B1  80 3D 0000015F R		cmp hitBool, 1
	   01
 000008B8  74 07			je YouGotEm
 000008BA  75 00			jne YouMissed

 000008BC				YouMissed:
 000008BC  E8 000000E1			call LogMiss

 000008C1			YouGotEm:
 000008C1  C3				ret
 000008C2			CheckAttkPlayer ENDP

				; recevies 
				;		esi: ship array
				;		ecx: ship size
 000008C2			ConfirmRowCols PROC USES eax ebx edx
				; mouse coords updated in PlayerTurn proc
 000008C2  50		   *	    push   eax
 000008C3  53		   *	    push   ebx
 000008C4  52		   *	    push   edx
 000008C5  8B 35 0000015B R		mov esi, currOffset
 000008CB  0F B6 0D			movzx ecx, currShipSize
	   00000157 R
 000008D2  66| A1			mov ax, ROW_COORD
	   00000704 R
 000008D8  66| 8B 1D			mov bx, COL_COORD
	   00000706 R
 000008DF				CheckRow:
 000008DF  38 06			cmp [esi], al	; exception thrown here
 000008E1  74 02			je CheckCol
 000008E3  EB 2F			jmp NextPlace

 000008E5				CheckCol:
 000008E5  46				inc esi
 000008E6  38 1E			cmp [esi], bl	; col coord (exception here now)
 000008E8  74 03			je BigHit
 000008EA  4E				dec esi
 000008EB  EB 27			jmp NextPlace

 000008ED				BigHit:
 000008ED  C6 05 0000015F R		mov hitBool, 1	; return this value on hit
	   01
 000008F4  8A 15 00000159 R		mov dl, currShipHealth
 000008FA  FE CA			dec dl
 000008FC  88 15 00000159 R		mov currShipHealth, dl
 00000902  80 3D 00000159 R		cmp currShipHealth, 0	; is it dead?
	   00
 00000909  74 02			je ShipSunk
 0000090B  EB 12			jmp JustAHit

 0000090D				ShipSunk:
 0000090D  E8 00000149			call ComputerShipSunk
 00000912  EB 0B			jmp JustAHit

 00000914				NextPlace:
 00000914  49				dec ecx
 00000915  83 F9 00			cmp ecx, 0	; if eq 0, return
 00000918  74 0A			je AllDone
 0000091A  83 C6 02			add esi, 2	; else adjust ptr
 0000091D  EB C0			jmp CheckRow

 0000091F				JustAHit:
 0000091F  E8 00000004			call LogHit

 00000924			AllDone:
					ret
 00000924  5A		   *	    pop    edx
 00000925  5B		   *	    pop    ebx
 00000926  58		   *	    pop    eax
 00000927  C3		   *	    ret    00000h
 00000928			ConfirmRowCols ENDP

				; places red 'X' on grid square of hit
 00000928			LogHit PROC USES eax ebx
					; change health values
 00000928  50		   *	    push   eax
 00000929  53		   *	    push   ebx
 0000092A  B8 00000000			mov eax, 0
 0000092F  A0 00000358 R		mov al, compHealth	; total health value (starts at 17)
 00000934  FE C8			dec al
 00000936  A2 00000358 R		mov compHealth, al
					; adjust map pointer
 0000093B  BF 00000264 R		mov edi, OFFSET ComputerMap
 00000940  03 3D 00000708 R		add edi, MAP_INDEX
 00000946  83 EF 28			sub edi, 40
					; update map square
 00000949  B3 58			mov bl, 'X'
 0000094B  88 1F			mov [edi], bl

					; write output
					mWriteAt 20, 25, clearLine
 0000094D  52		     2		push edx
 0000094E  B6 19	     2		mov  dh,25
 00000950  B2 14	     2		mov  dl,20
 00000952  E8 00000000 E     2		call Gotoxy
 00000957  5A		     2		pop  edx
 00000958  52		     2		push edx
 00000959  BA 0000073C R     2		mov  edx,OFFSET clearLine
 0000095E  E8 00000000 E     2		call WriteString
 00000963  5A		     2		pop  edx
					mWriteAt 20, 25, pTurnResult	;label
 00000964  52		     2		push edx
 00000965  B6 19	     2		mov  dh,25
 00000967  B2 14	     2		mov  dl,20
 00000969  E8 00000000 E     2		call Gotoxy
 0000096E  5A		     2		pop  edx
 0000096F  52		     2		push edx
 00000970  BA 000004EB R     2		mov  edx,OFFSET pTurnResult
 00000975  E8 00000000 E     2		call WriteString
 0000097A  5A		     2		pop  edx
					mSetTextColor lightRed
 0000097B  50		     1		push eax
 0000097C  B8 0000000C	     1		mov eax, lightRed
 00000981  E8 00000000 E     1		call SetTextColor
 00000986  58		     1		pop eax
					mWriteString hitResult			; hit
 00000987  52		     1		push edx
 00000988  BA 00000525 R     1		mov  edx,OFFSET hitResult
 0000098D  E8 00000000 E     1		call WriteString
 00000992  5A		     1		pop  edx
					mSetTextColor white
 00000993  50		     1		push eax
 00000994  B8 0000000F	     1		mov eax, white
 00000999  E8 00000000 E     1		call SetTextColor
 0000099E  58		     1		pop eax
					ret
 0000099F  5B		   *	    pop    ebx
 000009A0  58		   *	    pop    eax
 000009A1  C3		   *	    ret    00000h
 000009A2			LogHit ENDP


				; Prints white O in spot of the miss.
				; Notifies user their click was a miss.
 000009A2			LogMiss PROC USES edi ebx
 000009A2  57		   *	    push   edi
 000009A3  53		   *	    push   ebx
 000009A4  BF 00000264 R		mov edi, OFFSET ComputerMap
 000009A9  03 3D 00000708 R		add edi, MAP_INDEX
 000009AF  83 EF 28			sub edi, 40
 000009B2  B3 4F			mov bl, 'O'
 000009B4  88 1F			mov [edi], bl

					mWriteAt 20, 25, clearLine
 000009B6  52		     2		push edx
 000009B7  B6 19	     2		mov  dh,25
 000009B9  B2 14	     2		mov  dl,20
 000009BB  E8 00000000 E     2		call Gotoxy
 000009C0  5A		     2		pop  edx
 000009C1  52		     2		push edx
 000009C2  BA 0000073C R     2		mov  edx,OFFSET clearLine
 000009C7  E8 00000000 E     2		call WriteString
 000009CC  5A		     2		pop  edx
					mWriteAt 20, 25, pTurnResult	; label
 000009CD  52		     2		push edx
 000009CE  B6 19	     2		mov  dh,25
 000009D0  B2 14	     2		mov  dl,20
 000009D2  E8 00000000 E     2		call Gotoxy
 000009D7  5A		     2		pop  edx
 000009D8  52		     2		push edx
 000009D9  BA 000004EB R     2		mov  edx,OFFSET pTurnResult
 000009DE  E8 00000000 E     2		call WriteString
 000009E3  5A		     2		pop  edx
					mSetTextColor cyan
 000009E4  50		     1		push eax
 000009E5  B8 00000003	     1		mov eax, cyan
 000009EA  E8 00000000 E     1		call SetTextColor
 000009EF  58		     1		pop eax
					mWriteString missResult			; miss
 000009F0  52		     1		push edx
 000009F1  BA 0000052A R     1		mov  edx,OFFSET missResult
 000009F6  E8 00000000 E     1		call WriteString
 000009FB  5A		     1		pop  edx
					mSetTextColor white
 000009FC  50		     1		push eax
 000009FD  B8 0000000F	     1		mov eax, white
 00000A02  E8 00000000 E     1		call SetTextColor
 00000A07  58		     1		pop eax

					ret
 00000A08  5B		   *	    pop    ebx
 00000A09  5F		   *	    pop    edi
 00000A0A  C3		   *	    ret    00000h
 00000A0B			LogMiss ENDP

				; Clears screen and notifies player a ship was sunk
 00000A0B			PlayerShipSunk PROC
 00000A0B  E8 00000000 E		call Clrscr
					mSetTextColor red
 00000A10  50		     1		push eax
 00000A11  B8 00000004	     1		mov eax, red
 00000A16  E8 00000000 E     1		call SetTextColor
 00000A1B  58		     1		pop eax
					mWriteAt 30, 20, playerShipSunkMsg
 00000A1C  52		     2		push edx
 00000A1D  B6 14	     2		mov  dh,20
 00000A1F  B2 1E	     2		mov  dl,30
 00000A21  E8 00000000 E     2		call Gotoxy
 00000A26  5A		     2		pop  edx
 00000A27  52		     2		push edx
 00000A28  BA 0000060C R     2		mov  edx,OFFSET playerShipSunkMsg
 00000A2D  E8 00000000 E     2		call WriteString
 00000A32  5A		     2		pop  edx
					mSetTextColor white
 00000A33  50		     1		push eax
 00000A34  B8 0000000F	     1		mov eax, white
 00000A39  E8 00000000 E     1		call SetTextColor
 00000A3E  58		     1		pop eax
					mPause 3000
 00000A3F  50		     1		push eax
 00000A40  B8 00000BB8	     1		mov eax, 3000
 00000A45  E8 00000000 E     1		call Delay
 00000A4A  58		     1		pop eax
 00000A4B  E8 00000000 E		call Clrscr
 00000A50  E8 FFFFF794			call DrawMap
 00000A55  E8 FFFFF955			call PrintBottomText
 00000A5A  C3				ret
 00000A5B			PlayerShipSunk ENDP

				; Clears screen and notifies player a ship was sunk
 00000A5B			ComputerShipSunk PROC USES eax
 00000A5B  50		   *	    push   eax
 00000A5C  E8 00000000 E		call Clrscr
					mSetTextColor lightMagenta
 00000A61  50		     1		push eax
 00000A62  B8 0000000D	     1		mov eax, lightMagenta
 00000A67  E8 00000000 E     1		call SetTextColor
 00000A6C  58		     1		pop eax
					mWriteAt 25, 10, computerShipSunkMsg
 00000A6D  52		     2		push edx
 00000A6E  B6 0A	     2		mov  dh,10
 00000A70  B2 19	     2		mov  dl,25
 00000A72  E8 00000000 E     2		call Gotoxy
 00000A77  5A		     2		pop  edx
 00000A78  52		     2		push edx
 00000A79  BA 0000061D R     2		mov  edx,OFFSET computerShipSunkMsg
 00000A7E  E8 00000000 E     2		call WriteString
 00000A83  5A		     2		pop  edx
					mSetTextColor white
 00000A84  50		     1		push eax
 00000A85  B8 0000000F	     1		mov eax, white
 00000A8A  E8 00000000 E     1		call SetTextColor
 00000A8F  58		     1		pop eax
					mPause 3000
 00000A90  50		     1		push eax
 00000A91  B8 00000BB8	     1		mov eax, 3000
 00000A96  E8 00000000 E     1		call Delay
 00000A9B  58		     1		pop eax
 00000A9C  E8 00000000 E		call Clrscr
 00000AA1  E8 FFFFF743			call DrawMap
 00000AA6  E8 FFFFF904			call PrintBottomText
					ret
 00000AAB  58		   *	    pop    eax
 00000AAC  C3		   *	    ret    00000h
 00000AAD			ComputerShipSunk ENDP

				; Notifies user it is the computers turn.
				; generates a random point to attack
				; Checks if turn was hit or miss and updates the map accordingly.


 00000AAD			ComputerTurn PROC
					mSetTextColor lightRed
 00000AAD  50		     1		push eax
 00000AAE  B8 0000000C	     1		mov eax, lightRed
 00000AB3  E8 00000000 E     1		call SetTextColor
 00000AB8  58		     1		pop eax
					mWriteAt 20, 23, clearLine
 00000AB9  52		     2		push edx
 00000ABA  B6 17	     2		mov  dh,23
 00000ABC  B2 14	     2		mov  dl,20
 00000ABE  E8 00000000 E     2		call Gotoxy
 00000AC3  5A		     2		pop  edx
 00000AC4  52		     2		push edx
 00000AC5  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000ACA  E8 00000000 E     2		call WriteString
 00000ACF  5A		     2		pop  edx
					mWriteAt 20, 24, clearLine
 00000AD0  52		     2		push edx
 00000AD1  B6 18	     2		mov  dh,24
 00000AD3  B2 14	     2		mov  dl,20
 00000AD5  E8 00000000 E     2		call Gotoxy
 00000ADA  5A		     2		pop  edx
 00000ADB  52		     2		push edx
 00000ADC  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000AE1  E8 00000000 E     2		call WriteString
 00000AE6  5A		     2		pop  edx
					mWriteAt 20, 25, clearLine
 00000AE7  52		     2		push edx
 00000AE8  B6 19	     2		mov  dh,25
 00000AEA  B2 14	     2		mov  dl,20
 00000AEC  E8 00000000 E     2		call Gotoxy
 00000AF1  5A		     2		pop  edx
 00000AF2  52		     2		push edx
 00000AF3  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000AF8  E8 00000000 E     2		call WriteString
 00000AFD  5A		     2		pop  edx
					mWriteAt 20, 23, cTurnNotice
 00000AFE  52		     2		push edx
 00000AFF  B6 17	     2		mov  dh,23
 00000B01  B2 14	     2		mov  dl,20
 00000B03  E8 00000000 E     2		call Gotoxy
 00000B08  5A		     2		pop  edx
 00000B09  52		     2		push edx
 00000B0A  BA 000004D0 R     2		mov  edx,OFFSET cTurnNotice
 00000B0F  E8 00000000 E     2		call WriteString
 00000B14  5A		     2		pop  edx
					mSetTextColor white
 00000B15  50		     1		push eax
 00000B16  B8 0000000F	     1		mov eax, white
 00000B1B  E8 00000000 E     1		call SetTextColor
 00000B20  58		     1		pop eax
					mPause 3000
 00000B21  50		     1		push eax
 00000B22  B8 00000BB8	     1		mov eax, 3000
 00000B27  E8 00000000 E     1		call Delay
 00000B2C  58		     1		pop eax

 00000B2D				start:
					; initialize values
 00000B2D  C7 05 00000738 R		mov lowerbound, 6
	   00000006
 00000B37  C7 05 00000734 R		mov upperbound, 15
	   0000000F
 00000B41  E8 000002BA			call BoundedRandomNum	; random num in eax
					; simulate computer mouse click
 00000B46  66| A3			mov ROW_COORD, ax	
	   00000704 R
 00000B4C  C7 05 00000738 R		mov lowerbound, 23
	   00000017
 00000B56  C7 05 00000734 R		mov upperbound, 41
	   00000029
 00000B60  E8 000002B3			call GetRandomOdd
 00000B65  66| A3			mov COL_COORD, ax
	   00000706 R

					; convert to board coords
 00000B6B  E8 000005A3			call ConvertRowCoord
 00000B70  E8 000005C6			call ConvertColCoord

 00000B75  BF 0000016B R		mov edi, OFFSET PlayerMap
 00000B7A  03 3D 00000708 R		add edi, MAP_INDEX

 00000B80  B0 5F			mov al, '_'
 00000B82  3A 07			cmp al, [edi]
 00000B84  74 75			je cMiss

 00000B86  B0 4F			mov al, 'O'
 00000B88  3A 07			cmp al, [edi]
 00000B8A  74 A1			je Start	; retry, not a valid shot

 00000B8C  B0 58			mov al, 'X'
 00000B8E  3A 07			cmp al, [edi]
 00000B90  74 9B			je Start	; retru

 00000B92				cHit:
 00000B92  E8 000000F2			call CheckComputerTurnHit
					mWriteAt 20, 25, clearLine
 00000B97  52		     2		push edx
 00000B98  B6 19	     2		mov  dh,25
 00000B9A  B2 14	     2		mov  dl,20
 00000B9C  E8 00000000 E     2		call Gotoxy
 00000BA1  5A		     2		pop  edx
 00000BA2  52		     2		push edx
 00000BA3  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000BA8  E8 00000000 E     2		call WriteString
 00000BAD  5A		     2		pop  edx
					mWriteAt 20, 25, cTurnResult
 00000BAE  52		     2		push edx
 00000BAF  B6 19	     2		mov  dh,25
 00000BB1  B2 14	     2		mov  dl,20
 00000BB3  E8 00000000 E     2		call Gotoxy
 00000BB8  5A		     2		pop  edx
 00000BB9  52		     2		push edx
 00000BBA  BA 00000506 R     2		mov  edx,OFFSET cTurnResult
 00000BBF  E8 00000000 E     2		call WriteString
 00000BC4  5A		     2		pop  edx
					mSetTextColor lightRed
 00000BC5  50		     1		push eax
 00000BC6  B8 0000000C	     1		mov eax, lightRed
 00000BCB  E8 00000000 E     1		call SetTextColor
 00000BD0  58		     1		pop eax
					mWriteSpace 1
 0000072C		     1	.data
 0000072C  00000001 [	     1	??0000 BYTE 1 DUP(' '),0
	    20
	   ] 00
 00000BD1		     1	.code
 00000BD1  52		     1		push	edx
 00000BD2  BA 0000072C R     1		mov	edx,OFFSET ??0000
 00000BD7  E8 00000000 E     1		call	WriteString
 00000BDC  5A		     1		pop	edx
					mWriteString hitResult
 00000BDD  52		     1		push edx
 00000BDE  BA 00000525 R     1		mov  edx,OFFSET hitResult
 00000BE3  E8 00000000 E     1		call WriteString
 00000BE8  5A		     1		pop  edx
					mSetTextColor white
 00000BE9  50		     1		push eax
 00000BEA  B8 0000000F	     1		mov eax, white
 00000BEF  E8 00000000 E     1		call SetTextColor
 00000BF4  58		     1		pop eax

 00000BF5  B0 58			mov al, 'X'
 00000BF7  88 07			mov [edi], al

 00000BF9  EB 62			jmp redraw

 00000BFB				cMiss:
 00000BFB				skip:
					mWriteAt 20, 25, clearLine
 00000BFB  52		     2		push edx
 00000BFC  B6 19	     2		mov  dh,25
 00000BFE  B2 14	     2		mov  dl,20
 00000C00  E8 00000000 E     2		call Gotoxy
 00000C05  5A		     2		pop  edx
 00000C06  52		     2		push edx
 00000C07  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000C0C  E8 00000000 E     2		call WriteString
 00000C11  5A		     2		pop  edx
					mWriteAt 20, 25, cTurnResult
 00000C12  52		     2		push edx
 00000C13  B6 19	     2		mov  dh,25
 00000C15  B2 14	     2		mov  dl,20
 00000C17  E8 00000000 E     2		call Gotoxy
 00000C1C  5A		     2		pop  edx
 00000C1D  52		     2		push edx
 00000C1E  BA 00000506 R     2		mov  edx,OFFSET cTurnResult
 00000C23  E8 00000000 E     2		call WriteString
 00000C28  5A		     2		pop  edx
					mSetTextColor cyan
 00000C29  50		     1		push eax
 00000C2A  B8 00000003	     1		mov eax, cyan
 00000C2F  E8 00000000 E     1		call SetTextColor
 00000C34  58		     1		pop eax
					mWriteSpace 1
 0000072E		     1	.data
 0000072E  00000001 [	     1	??0001 BYTE 1 DUP(' '),0
	    20
	   ] 00
 00000C35		     1	.code
 00000C35  52		     1		push	edx
 00000C36  BA 0000072E R     1		mov	edx,OFFSET ??0001
 00000C3B  E8 00000000 E     1		call	WriteString
 00000C40  5A		     1		pop	edx
					mWriteString missResult
 00000C41  52		     1		push edx
 00000C42  BA 0000052A R     1		mov  edx,OFFSET missResult
 00000C47  E8 00000000 E     1		call WriteString
 00000C4C  5A		     1		pop  edx
					mSetTextColor white
 00000C4D  50		     1		push eax
 00000C4E  B8 0000000F	     1		mov eax, white
 00000C53  E8 00000000 E     1		call SetTextColor
 00000C58  58		     1		pop eax
 00000C59  B0 4F			mov al, 'O'
 00000C5B  88 07			mov [edi], al

 00000C5D				redraw:
 00000C5D  E8 FFFFF587			call DrawMap
 00000C62  E8 FFFFF748			call PrintBottomText

					; if ship sunk call proc
 00000C67  80 3D 00000357 R		cmp isSunk, 1
	   01
					; else return
 00000C6E  75 0C			jne return
 00000C70  E8 FFFFFD96			call PlayerShipSunk
 00000C75  C6 05 00000357 R		mov isSunk, 0
	   00

 00000C7C				return:
					mPause 1000
 00000C7C  50		     1		push eax
 00000C7D  B8 000003E8	     1		mov eax, 1000
 00000C82  E8 00000000 E     1		call Delay
 00000C87  58		     1		pop eax
 00000C88  C3				ret
 00000C89			ComputerTurn ENDP


				; Call this when hit is confirmed to check what ship was hit.
				; compare location to map ascii
				; Recieves: Pointer to coordinate on the map (EDI).
 00000C89			CheckComputerTurnHit PROC USES edx ebx eax
 00000C89  52		   *	    push   edx
 00000C8A  53		   *	    push   ebx
 00000C8B  50		   *	    push   eax
 00000C8C  B6 00			mov dh, 0

					; if battleship, check bship hp
 00000C8E  B3 42			mov bl, 'B'
 00000C90  38 1F			cmp [edi], bl
 00000C92  74 2B			je HitB

					; if carrier, check carrier hp
 00000C94  B3 43			mov bl, 'C'
 00000C96  38 1F			cmp [edi], bl
 00000C98  74 43			je HitC

 00000C9A  B3 44			mov bl, 'D'
 00000C9C  38 1F			cmp [edi], bl
 00000C9E  74 5B			je HitD

 00000CA0  B3 55			mov bl, 'U'
 00000CA2  38 1F			cmp [edi], bl
 00000CA4  74 73			je HitU

					; else hit a sweeper
 00000CA6  A0 00000263 R		mov al, PlayerSweeperHealth
 00000CAB  FE C8			dec al
					mCheckSunk PlayerSweeperHealth
 00000CAD  80 3D 00000263 R
	   00		   *	    cmp    playerSweeperHealth, 000h
 00000CB4  75 07	   *	    jne    @C0015
 00000CB6  C6 05 00000357 R  1			mov isSunk, 1
	   01
 00000CBD		   *@C0015:
 00000CBD  EB 78			jmp Return

 00000CBF				HitB:
 00000CBF  A0 00000260 R		mov al, PlayerBattleshipHealth
 00000CC4  FE C8			dec al
 00000CC6  A2 00000260 R		mov PlayerBattleshipHealth, al
					mCheckSunk PlayerBattleshipHealth
 00000CCB  80 3D 00000260 R
	   00		   *	    cmp    playerBattleshipHealth, 000h
 00000CD2  75 07	   *	    jne    @C0017
 00000CD4  C6 05 00000357 R  1			mov isSunk, 1
	   01
 00000CDB		   *@C0017:
 00000CDB  EB 5A			jmp Return

 00000CDD				HitC:
 00000CDD  A0 0000025F R		mov al, PlayerCarrierHealth
 00000CE2  FE C8			dec al
 00000CE4  A2 0000025F R		mov PlayerCarrierHealth, al
					mCheckSunk PlayerCarrierHealth
 00000CE9  80 3D 0000025F R
	   00		   *	    cmp    playerCarrierHealth, 000h
 00000CF0  75 07	   *	    jne    @C0019
 00000CF2  C6 05 00000357 R  1			mov isSunk, 1
	   01
 00000CF9		   *@C0019:
 00000CF9  EB 3C			jmp Return

 00000CFB				HitD:
 00000CFB  A0 00000262 R		mov al, PlayerDestroyerHealth
 00000D00  FE C8			dec al
 00000D02  A2 00000262 R		mov PlayerDestroyerHealth, al
					mCheckSunk PlayerDestroyerHealth
 00000D07  80 3D 00000262 R
	   00		   *	    cmp    playerDestroyerHealth, 000h
 00000D0E  75 07	   *	    jne    @C001B
 00000D10  C6 05 00000357 R  1			mov isSunk, 1
	   01
 00000D17		   *@C001B:
 00000D17  EB 1E			jmp Return

 00000D19				HitU:
 00000D19  A0 00000261 R		mov al, PlayerSubmarineHealth
 00000D1E  FE C8			dec al
 00000D20  A2 00000261 R		mov PlayerSubmarineHealth, al
					mCheckSunk PlayerSubmarineHealth
 00000D25  80 3D 00000261 R
	   00		   *	    cmp    playerSubmarineHealth, 000h
 00000D2C  75 07	   *	    jne    @C001D
 00000D2E  C6 05 00000357 R  1			mov isSunk, 1
	   01
 00000D35		   *@C001D:
 00000D35  EB 00			jmp Return

 00000D37				Return:
 00000D37  A0 0000025E R		mov al, PlayerHealth
 00000D3C  FE C8			dec al
 00000D3E  A2 0000025E R		mov PlayerHealth, al
					ret
 00000D43  58		   *	    pop    eax
 00000D44  5B		   *	    pop    ebx
 00000D45  5A		   *	    pop    edx
 00000D46  C3		   *	    ret    00000h
 00000D47			CheckComputerTurnHit ENDP


				; ***********************************************************************************
				;		Helper Functions
				; ***********************************************************************************

 00000730			.data
 00000730 00000000		savedLocation DWORD ?
 00000734 00000000		upperBound DWORD ?
 00000738 00000000		lowerBound DWORD ?
 0000073C 20 20 20 20 20	clearLine BYTE "                                                                                                  ", 0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 00
 0000079F 00			savedShiphealth BYTE ?
 000007A0 00			currentCol BYTE ?
 000007A1 00			currentRow BYTE ?

 00000D47			.code

				; Clears the lower area in the UI for displaying directions
				; Helps keep the direction section of the UI clean and readable
				; otherwise chars get written on top of chars until it's a mess
 00000D47			ClearDirections PROC
					; overwrite chars at these positions with blank line
					;mWriteAt 20, 22, clearLine
					;mWriteAt 20, 22, clearLine
					mWriteAt 10, 23, clearLine
 00000D47  52		     2		push edx
 00000D48  B6 17	     2		mov  dh,23
 00000D4A  B2 0A	     2		mov  dl,10
 00000D4C  E8 00000000 E     2		call Gotoxy
 00000D51  5A		     2		pop  edx
 00000D52  52		     2		push edx
 00000D53  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000D58  E8 00000000 E     2		call WriteString
 00000D5D  5A		     2		pop  edx
					mWriteAt 10, 24, clearLine
 00000D5E  52		     2		push edx
 00000D5F  B6 18	     2		mov  dh,24
 00000D61  B2 0A	     2		mov  dl,10
 00000D63  E8 00000000 E     2		call Gotoxy
 00000D68  5A		     2		pop  edx
 00000D69  52		     2		push edx
 00000D6A  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000D6F  E8 00000000 E     2		call WriteString
 00000D74  5A		     2		pop  edx
					mWriteAt 10, 25, clearLine
 00000D75  52		     2		push edx
 00000D76  B6 19	     2		mov  dh,25
 00000D78  B2 0A	     2		mov  dl,10
 00000D7A  E8 00000000 E     2		call Gotoxy
 00000D7F  5A		     2		pop  edx
 00000D80  52		     2		push edx
 00000D81  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000D86  E8 00000000 E     2		call WriteString
 00000D8B  5A		     2		pop  edx
					mWriteAt 10, 26, clearLine
 00000D8C  52		     2		push edx
 00000D8D  B6 1A	     2		mov  dh,26
 00000D8F  B2 0A	     2		mov  dl,10
 00000D91  E8 00000000 E     2		call Gotoxy
 00000D96  5A		     2		pop  edx
 00000D97  52		     2		push edx
 00000D98  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000D9D  E8 00000000 E     2		call WriteString
 00000DA2  5A		     2		pop  edx
					mWriteAt 10, 27, clearLine
 00000DA3  52		     2		push edx
 00000DA4  B6 1B	     2		mov  dh,27
 00000DA6  B2 0A	     2		mov  dl,10
 00000DA8  E8 00000000 E     2		call Gotoxy
 00000DAD  5A		     2		pop  edx
 00000DAE  52		     2		push edx
 00000DAF  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000DB4  E8 00000000 E     2		call WriteString
 00000DB9  5A		     2		pop  edx
					mWriteAt 10, 28, clearLine
 00000DBA  52		     2		push edx
 00000DBB  B6 1C	     2		mov  dh,28
 00000DBD  B2 0A	     2		mov  dl,10
 00000DBF  E8 00000000 E     2		call Gotoxy
 00000DC4  5A		     2		pop  edx
 00000DC5  52		     2		push edx
 00000DC6  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000DCB  E8 00000000 E     2		call WriteString
 00000DD0  5A		     2		pop  edx
					mWriteAt 10, 29, clearLine
 00000DD1  52		     2		push edx
 00000DD2  B6 1D	     2		mov  dh,29
 00000DD4  B2 0A	     2		mov  dl,10
 00000DD6  E8 00000000 E     2		call Gotoxy
 00000DDB  5A		     2		pop  edx
 00000DDC  52		     2		push edx
 00000DDD  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000DE2  E8 00000000 E     2		call WriteString
 00000DE7  5A		     2		pop  edx
					mWriteAt 10, 30, clearLine
 00000DE8  52		     2		push edx
 00000DE9  B6 1E	     2		mov  dh,30
 00000DEB  B2 0A	     2		mov  dl,10
 00000DED  E8 00000000 E     2		call Gotoxy
 00000DF2  5A		     2		pop  edx
 00000DF3  52		     2		push edx
 00000DF4  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00000DF9  E8 00000000 E     2		call WriteString
 00000DFE  5A		     2		pop  edx
					;mov edx, 0
					;call GoToXY
 00000DFF  C3				ret
 00000E00			ClearDirections ENDP

				; Produces a random int with lower and upper bound.
				; Receives: upperBound, lowerBound.
				; Returns: eax
				; RandomRange: receives max in eax, returns random in eax
 00000E00			BoundedRandomNum PROC USES ebx
 00000E00  53		   *	    push   ebx
 00000E01  8B 1D 00000738 R		mov ebx, lowerBound
 00000E07  A1 00000734 R		mov eax, upperBound
 00000E0C  2B C3			sub eax, ebx
 00000E0E  40				inc eax
 00000E0F  E8 00000000 E		call RandomRange
 00000E14  03 C3			add eax, ebx
					ret
 00000E16  5B		   *	    pop    ebx
 00000E17  C3		   *	    ret    00000h
 00000E18			BoundedRandomNum ENDP

				; uses random range to get an odd number
				; bounded by upper and lower
				; receives upper/lower bound
				; returns eax
				; RandomRange: receives max in eax, returns random in eax
 00000E18			GetRandomOdd PROC USES ebx
 00000E18  53		   *	    push   ebx
 00000E19  8B 1D 00000738 R		mov ebx, lowerbound
 00000E1F  A1 00000734 R		mov eax, upperbound
 00000E24  2B C3			sub eax, ebx
 00000E26  40				inc eax
 00000E27  E8 00000000 E		call RandomRange
 00000E2C  03 C3			add eax, ebx
 00000E2E  8B D0			mov edx, eax
 00000E30  B3 02			mov bl, 2
 00000E32  F6 F3			div bl
 00000E34  80 FC 00			cmp ah, 0
 00000E37  75 0C			jne Found
 00000E39  3B 15 00000734 R		cmp edx, upperbound
 00000E3F  74 03			je decrement
 00000E41  42				inc edx
 00000E42  EB 01			jmp Found

 00000E44				decrement:
 00000E44  4A				dec edx

 00000E45				Found:
 00000E45  8B C2			mov eax, edx
					ret
 00000E47  5B		   *	    pop    ebx
 00000E48  C3		   *	    ret    00000h
 00000E49			GetRandomOdd endp

				; Bounds = mapLen - shipSize
				; receives ship array @ esi
				; dl: length of ship
 00000E49			GetCoordsH PROC USES ebx
					; set up the bounds
 00000E49  53		   *	    push   ebx
 00000E4A  8A 3D 00000168 R		mov bh, COL_MAX
 00000E50  2A 3D 00000157 R		sub bh, currShipSize	; subtract length of ship from max col
 00000E56  0F B6 DF			movzx ebx, bh		; save that number in ebx
 00000E59  89 1D 00000734 R		mov upperbound, ebx	; save it as upperbound
 00000E5F  0F B6 1D			movzx ebx, COL_MIN	; use col-min to find random num
	   00000167 R
 00000E66  89 1D 00000738 R		mov lowerbound, ebx
 00000E6C  E8 FFFFFFA7			call GetRandomOdd	; random odd number now in eax
 00000E71  A2 000007A0 R		mov currentCol, al	; save as current col
 00000E76  88 06			mov [esi], al		; move into the ship array
 00000E78  4E				dec esi				; adjust pointer

 00000E79  0F B6 1D			movzx ebx, ROW_MAX
	   0000016A R
 00000E80  89 1D 00000734 R		mov upperbound, ebx
 00000E86  0F B6 1D			movzx ebx, ROW_MIN
	   00000169 R
 00000E8D  89 1D 00000738 R		mov lowerbound, ebx
 00000E93  E8 FFFFFF68			call BoundedRandomNum
 00000E98  A2 000007A1 R		mov currentRow, al
 00000E9D  88 06			mov [esi], al
 00000E9F  46				inc esi

					ret
 00000EA0  5B		   *	    pop    ebx
 00000EA1  C3		   *	    ret    00000h
 00000EA2			GetCoordsH ENDP

				; Bounds = mapHeight - shipLen
				; Picks a random column coordinate.
				; Recieves: ship to be filled @ esi
 00000EA2			GetCoordsV PROC USES ebx
 00000EA2  53		   *	    push   ebx
 00000EA3  8A 3D 0000016A R		mov bh, ROW_MAX
 00000EA9  2A FA			sub bh, dl
 00000EAB  0F B6 DF			movzx ebx, bh
 00000EAE  89 1D 00000734 R		mov upperbound, ebx
 00000EB4  0F B6 1D			movzx ebx, ROW_MIN
	   00000169 R
 00000EBB  89 1D 00000738 R		mov lowerbound, ebx
 00000EC1  E8 FFFFFF3A			call BoundedRandomNum
 00000EC6  A2 000007A1 R		mov currentRow, al
 00000ECB  88 06			mov [esi], al
 00000ECD  46				inc esi
 00000ECE  0F B6 1D			movzx ebx, COL_MAX
	   00000168 R
 00000ED5  89 1D 00000734 R		mov upperbound, ebx
 00000EDB  0F B6 1D			movzx ebx, COL_MIN
	   00000167 R
 00000EE2  89 1D 00000738 R		mov lowerbound, ebx
 00000EE8  E8 FFFFFF2B			call GetRandomOdd
 00000EED  A2 000007A0 R		mov currentCol, al
 00000EF2  88 06			mov [esi], al

					ret
 00000EF4  5B		   *	    pop    ebx
 00000EF5  C3		   *	    ret    00000h
 00000EF6			GetCoordsV ENDP

				; Fills vertical @ esi
				; start point chosen by getcoordsV proc.
 00000EF6			FillArrayV PROC USES edx
					; current map position
 00000EF6  52		   *	    push   edx
 00000EF7  8A 35 000007A1 R		mov dh, currentRow
 00000EFD  8A 15 000007A0 R		mov dl, currentCol
					; loop through len of ship
 00000F03				Lisa:
 00000F03  46					inc esi
 00000F04  FE C6				inc dh
 00000F06  88 36				mov [esi], dh
 00000F08  46					inc esi
 00000F09  88 16				mov [esi], dl
 00000F0B  E2 F6			loop Lisa

				ret
 00000F0D  5A		   *	    pop    edx
 00000F0E  C3		   *	    ret    00000h
 00000F0F			FillArrayV ENDP

				; Fills horizontal array @ esi
				; start point chosen by getcoordsH proc.
 00000F0F			FillArrayH PROC USES edx
					; current board position
 00000F0F  52		   *	    push   edx
 00000F10  8A 35 000007A1 R		mov dh, currentRow
 00000F16  8A 15 000007A0 R		mov dl, currentCol
					; loop through length of ship
 00000F1C				Doug:
 00000F1C  46					inc esi
 00000F1D  80 C2 02				add dl, 2
 00000F20  88 36				mov [esi], dh
 00000F22  46					inc esi
 00000F23  88 16				mov [esi], dl
 00000F25  E2 F5			loop Doug
				ret
 00000F27  5A		   *	    pop    edx
 00000F28  C3		   *	    ret    00000h
 00000F29			FillArrayH ENDP

				; checks against all ships
				; if there is a collision it returns 1 in intersection variable
 00000F29			CheckRandomCollision PROC
 00000F29  C6 05 00000160 R		mov intersect, 0
	   00
 00000F30  8B DE			mov ebx, esi
 00000F32  8B D1			mov edx, ecx
					; check once for each ship
 00000F34  C7 05 00000730 R		mov savedLocation, OFFSET compCarrierArray
	   0000035E R
 00000F3E  0F B6 05			movzx eax, compCarrierHealth
	   00000359 R
 00000F45  A2 0000079F R		mov savedShipHealth, al
 00000F4A  E8 00000076			call CheckShipCollision
 00000F4F  00 05 00000160 R		add intersect, al

 00000F55  8B F3			mov esi, ebx
 00000F57  8B CA			mov ecx, edx
 00000F59  C7 05 00000730 R		mov savedLocation, OFFSET compBshipArray
	   00000368 R
 00000F63  0F B6 05			movzx eax, compBshipHealth
	   0000035A R
 00000F6A  A2 0000079F R		mov savedShipHealth, al
 00000F6F  E8 00000051			call CheckShipCollision
 00000F74  00 05 00000160 R		add intersect, al

 00000F7A  8B F3			mov esi, ebx
 00000F7C  8B CA			mov ecx, edx
 00000F7E  C7 05 00000730 R		mov savedLocation, OFFSET compSubArray
	   00000370 R
 00000F88  0F B6 05			movzx eax, compSubHealth
	   0000035B R
 00000F8F  A2 0000079F R		mov savedShipHealth, al
 00000F94  E8 0000002C			call CheckShipCollision
 00000F99  00 05 00000160 R		add intersect, al


 00000F9F  8B F3			mov esi, ebx
 00000FA1  8B CA			mov ecx, edx
 00000FA3  C7 05 00000730 R		mov savedLocation, OFFSET compDestroyerArray
	   00000376 R
 00000FAD  0F B6 05			movzx eax, compDestroyerHealth
	   0000035C R
 00000FB4  A2 0000079F R		mov savedShipHealth, al
 00000FB9  E8 00000007			call CheckShipCollision
 00000FBE  00 05 00000160 R		add intersect, al

 00000FC4				return:
 00000FC4  C3				ret
 00000FC5			CheckRandomCollision ENDP

				; Double Loop to check if any point in the two ship arrays match
				; Recieves: Pointers to both ships (ESI, EDI) Health of each ship (ECX, currentshiphealth)
				; TODO: fix esi index location, or comparisons.  need more time
 00000FC5			CheckShipCollision PROC uses EBX EDX
 00000FC5  53		   *	    push   ebx
 00000FC6  52		   *	    push   edx
 00000FC7  B0 00			mov al, 0
 00000FC9				LoopOuter:
 00000FC9  8A 3E				mov bh, [esi]
 00000FCB  46					inc esi
 00000FCC  8A 1E				mov bl, [esi]
 00000FCE  46					inc esi
 00000FCF  51					push ecx
 00000FD0  8B 3D 00000730 R			mov edi, savedLocation
 00000FD6  0F B6 0D				movzx ecx, savedShipHealth
	   0000079F R
 00000FDD					LoopInner:
 00000FDD  8A 37					mov dh, [edi]
 00000FDF  47						inc edi
 00000FE0  8A 17					mov dl, [edi]
 00000FE2  47						inc edi
 00000FE3  3A F7					cmp dh, bh
 00000FE5  75 06					jne next
 00000FE7  3A D3					cmp dl, bl
 00000FE9  75 02					jne next
 00000FEB  FE C0					inc al

 00000FED						next:
 00000FED  E2 EE					loop LoopInner
 00000FEF  59					pop ecx
 00000FF0  3C 01				cmp al, 1
 00000FF2  74 02				je return
 00000FF4  E2 D3				loop LoopOuter

 00000FF6				return:
					ret
 00000FF6  5A		   *	    pop    edx
 00000FF7  5B		   *	    pop    ebx
 00000FF8  C3		   *	    ret    00000h
 00000FF9			CheckShipCollision ENDP

				; prints instructions at bottom of screen
 00000FF9			PrintShipInstructions PROC
					mSetTextColor gray
 00000FF9  50		     1		push eax
 00000FFA  B8 00000008	     1		mov eax, gray
 00000FFF  E8 00000000 E     1		call SetTextColor
 00001004  58		     1		pop eax
					mWriteAt 20, 25, shipToPlace
 00001005  52		     2		push edx
 00001006  B6 19	     2		mov  dh,25
 00001008  B2 14	     2		mov  dl,20
 0000100A  E8 00000000 E     2		call Gotoxy
 0000100F  5A		     2		pop  edx
 00001010  52		     2		push edx
 00001011  BA 0000058B R     2		mov  edx,OFFSET shipToPlace
 00001016  E8 00000000 E     2		call WriteString
 0000101B  5A		     2		pop  edx
					mSetTextColor white
 0000101C  50		     1		push eax
 0000101D  B8 0000000F	     1		mov eax, white
 00001022  E8 00000000 E     1		call SetTextColor
 00001027  58		     1		pop eax
 00001028  C3				ret
 00001029			PrintShipInstructions ENDP

 00001029			GetMouseAlt PROC
					; nevermind
 00001029  C3				ret
 0000102A			GetMouseAlt ENDP


				;  X = Row Coordinate, Y = Column Coordinate
				; Returns row in bx, col in ax
				; Uses InputRecord struct to compare
				; Updates ROW_COORD and COL_COORD
 0000102A			GetMouseLoc PROC USES edx ebx eax
					; get handles and console info from Irvine libraries
 0000102A  52		   *	    push   edx
 0000102B  53		   *	    push   ebx
 0000102C  50		   *	    push   eax
					INVOKE GetStdHandle, STD_INPUT_HANDLE
 0000102D  6A F6	   *	    push    -00000000Ah
 0000102F  E8 00000000 E   *	    call   GetStdHandle
 00001034  A3 00000724 R		mov hStdln, eax
					INVOKE GetConsoleMode, hStdln, ADDR ConsoleMode
 00001039  68 00000720 R   *	    push   OFFSET ConsoleMode
 0000103E  FF 35 00000724 R *	    push   hStdln
 00001044  E8 00000000 E   *	    call   GetConsoleMode
 00001049  B8 00000090			mov eax, 0090h	; = enable_mouse_input
					INVOKE SetConsoleMode, hStdln, eax
 0000104E  50		   *	    push   eax
 0000104F  FF 35 00000724 R *	    push   hStdln
 00001055  E8 00000000 E   *	    call   SetConsoleMode

 0000105A				Begin:
					INVOKE ReadConsoleInput, hStdln, ADDR InputRecord, 1, ADDR nRead
 0000105A  68 00000728 R   *	    push   OFFSET nRead
 0000105F  6A 01	   *	    push   +000000001h
 00001061  68 0000070C R   *	    push   OFFSET InputRecord
 00001066  FF 35 00000724 R *	    push   hStdln
 0000106C  E8 00000000 E   *	    call   ReadConsoleInputA
 00001071  0F B7 05			movzx eax, InputRecord.EventType
	   0000070C R
 00001078  0F 85 00000088		jne skip
 0000107E  83 3D 00000714 R		cmp InputRecord.MouseEvent.dwButtonState, 2
	   02
 00001085  74 45			je HandleRightClick
 00001087  83 3D 00000714 R		cmp InputRecord.MouseEvent.dwButtonState, 1
	   01
 0000108E  75 76			jne skip
 00001090  74 00			je HandleLeftClick

					; http://programming.msjc.edu/asm/help/index.html?page=source%2Fwin32lib%2Fwriteconsoleoutputcharacter.htm
					; Note: mouseEvent struct contains dwMousePosition which is a COORD struct
					;		Use this to get x and y positions of mouse
 00001092				HandleLeftClick:
 00001092  66| A1			mov ax, InputRecord.MouseEvent.dwMousePosition.X
	   00000710 R
 00001098  66| BA 0000			mov dx, 0
 0000109C  66| BB 0002			mov bx, 2
 000010A0  66| F7 F3			div bx
 000010A3  66| 83 FA 00			cmp dx, 0
 000010A7  74 5D			je skip
 000010A9  66| A1			mov ax, InputRecord.MouseEvent.dwMousePosition.X
	   00000710 R
 000010AF  66| 8B 1D			mov bx, InputRecord.MouseEvent.dwMousePosition.Y
	   00000712 R
 000010B6  C6 05 00000156 R		mov mouseNum, 1
	   01
 000010BD  66| 89 1D			mov ROW_COORD, bx
	   00000704 R
 000010C4  66| A3			mov COL_COORD, ax
	   00000706 R
 000010CA  EB 43			jmp Complete

 000010CC				HandleRightClick:
 000010CC  66| A1			mov ax, InputRecord.MouseEvent.dwMousePosition.X
	   00000710 R
 000010D2  66| BA 0000			mov dx, 0
 000010D6  66| BB 0002			mov bx, 2
 000010DA  66| F7 F3			div bx
 000010DD  66| 83 FA 00			cmp dx, 0
 000010E1  74 23			je skip
 000010E3  66| A1			mov ax, InputRecord.MouseEvent.dwMousePosition.X
	   00000710 R
 000010E9  66| 8B 1D			mov bx, InputRecord.MouseEvent.dwMousePosition.Y
	   00000712 R
 000010F0  C6 05 00000156 R		mov mouseNum, 2
	   02
 000010F7  66| 89 1D			mov ROW_COORD, bx
	   00000704 R
 000010FE  66| A3			mov COL_COORD, ax
	   00000706 R
 00001104  EB 09			jmp Complete

 00001106				skip:	; do not register click, try again
 00001106  83 F9 00			cmp ecx, 0
 00001109  0F 85 FFFFFF4B		jne Begin

 0000110F				Complete:
					ret
 0000110F  58		   *	    pop    eax
 00001110  5B		   *	    pop    ebx
 00001111  5A		   *	    pop    edx
 00001112  C3		   *	    ret    00000h
 00001113			GetMouseLoc ENDP

				; Makes X-coordinate from mouse click to be compatible with battleship map.
				;	Returns: Updated map index
 00001113			ConvertRowCoord PROC USES eax ebx
 00001113  50		   *	    push   eax
 00001114  53		   *	    push   ebx
 00001115  B8 00000000			mov eax, 0
 0000111A  B8 00000019			mov eax, 25	; A1 in Map
 0000111F  66| BB 0006			mov bx, 6	; Starting X-Row coordinate in console

 00001123				SeekRow:
 00001123  66| 3B 1D				cmp bx, ROW_COORD
	   00000704 R
 0000112A  74 07				je RowFound
 0000112C  83 C0 16				add eax, 22
 0000112F  66| 43				inc bx
 00001131  EB F0			jmp SeekRow

 00001133				RowFound:
 00001133  A3 00000708 R		mov MAP_INDEX, eax
					ret
 00001138  5B		   *	    pop    ebx
 00001139  58		   *	    pop    eax
 0000113A  C3		   *	    ret    00000h
 0000113B			ConvertRowCoord ENDP


				; Makes Y-coordinate from mouse click to be compatible with the battleship map.
				;	Returns: Updated MAP_INDEX
 0000113B			ConvertColCoord PROC USES eax ebx
 0000113B  50		   *	    push   eax
 0000113C  53		   *	    push   ebx
 0000113D  A1 00000708 R		mov eax, MAP_INDEX	; Starting from where we are in the row of the map
 00001142  66| BB 0017			mov bx, 23			; Starting coordinate for A-column

 00001146				SeekColumn:
 00001146  66| 3B 1D				cmp bx, COL_COORD
	   00000706 R
 0000114D  74 08				je ColumnFound
 0000114F  83 C3 02				add ebx, 2
 00001152  83 C0 02				add eax, 2
 00001155  EB EF			jmp SeekColumn

 00001157				ColumnFound:
 00001157  A3 00000708 R		mov MAP_INDEX, eax
					ret
 0000115C  5B		   *	    pop    ebx
 0000115D  58		   *	    pop    eax
 0000115E  C3		   *	    ret    00000h
 0000115F			ConvertColCoord ENDP


				; Checks if player ship placement is valid
				; Compares grid square to '_'
				; Retry ship placement if there is an error
				;	ecx = size of ship
 0000115F			DetectVertical PROC USES eax ecx edi
 0000115F  50		   *	    push   eax
 00001160  51		   *	    push   ecx
 00001161  57		   *	    push   edi
 00001162  BF 0000016B R		mov edi, OFFSET PlayerMap
 00001167  03 3D 00000708 R		add edi, MAP_INDEX
 0000116D  0F B6 CB			movzx ecx, bl
 00001170  8A 25 00000166 R		mov ah, _EMPTY_
 00001176				CheckV:
 00001176  38 27				cmp [edi], ah
 00001178  75 07				jne ErrorV
 0000117A  83 C7 16				add edi, 22		; +22 to next _ in curr row
 0000117D  E2 F7			loop CheckV

 0000117F  EB 4B			jmp ValidV

					; writes an error message if detect occupied grid
 00001181				ErrorV:
					mWriteAt 20, 28, clearLine
 00001181  52		     2		push edx
 00001182  B6 1C	     2		mov  dh,28
 00001184  B2 14	     2		mov  dl,20
 00001186  E8 00000000 E     2		call Gotoxy
 0000118B  5A		     2		pop  edx
 0000118C  52		     2		push edx
 0000118D  BA 0000073C R     2		mov  edx,OFFSET clearLine
 00001192  E8 00000000 E     2		call WriteString
 00001197  5A		     2		pop  edx
					mSetTextColor lightRed
 00001198  50		     1		push eax
 00001199  B8 0000000C	     1		mov eax, lightRed
 0000119E  E8 00000000 E     1		call SetTextColor
 000011A3  58		     1		pop eax
					mWriteAt 20, 28, PlacementError
 000011A4  52		     2		push edx
 000011A5  B6 1C	     2		mov  dh,28
 000011A7  B2 14	     2		mov  dl,20
 000011A9  E8 00000000 E     2		call Gotoxy
 000011AE  5A		     2		pop  edx
 000011AF  52		     2		push edx
 000011B0  BA 000006D5 R     2		mov  edx,OFFSET PlacementError
 000011B5  E8 00000000 E     2		call WriteString
 000011BA  5A		     2		pop  edx
					mSetTextColor white
 000011BB  50		     1		push eax
 000011BC  B8 0000000F	     1		mov eax, white
 000011C1  E8 00000000 E     1		call SetTextColor
 000011C6  58		     1		pop eax
 000011C7  BA 00000001			mov edx, 1	; set 1 = error

 000011CC			ValidV:
					ret
 000011CC  5F		   *	    pop    edi
 000011CD  59		   *	    pop    ecx
 000011CE  58		   *	    pop    eax
 000011CF  C3		   *	    ret    00000h
 000011D0			DetectVertical ENDP

				; Checks if player ship placement is valid
				; Compares grid square to '_'
				; Retry ship placement if there is an error
				;	ecx = size of ship
 000011D0			DetectHorizontal PROC USES eax ecx edi
 000011D0  50		   *	    push   eax
 000011D1  51		   *	    push   ecx
 000011D2  57		   *	    push   edi
 000011D3  BF 0000016B R		mov edi, OFFSET PlayerMap
 000011D8  03 3D 00000708 R		add edi, MAP_INDEX
 000011DE  0F B6 CB			movzx ecx, bl
 000011E1  8A 25 00000166 R		mov ah, _EMPTY_
 000011E7				CheckH:
 000011E7  38 27				cmp [edi], ah
 000011E9  75 07				jne ErrorH
 000011EB  83 C7 02				add edi, 2	; +2 to next _ in curr row
 000011EE  E2 F7			loop CheckH

 000011F0  EB 4D			jmp ValidH

					; prints the error message
 000011F2				ErrorH:
					mWriteAt 20, 28, ClearLine
 000011F2  52		     2		push edx
 000011F3  B6 1C	     2		mov  dh,28
 000011F5  B2 14	     2		mov  dl,20
 000011F7  E8 00000000 E     2		call Gotoxy
 000011FC  5A		     2		pop  edx
 000011FD  52		     2		push edx
 000011FE  BA 0000073C R     2		mov  edx,OFFSET ClearLine
 00001203  E8 00000000 E     2		call WriteString
 00001208  5A		     2		pop  edx
					mSetTextColor lightRed
 00001209  50		     1		push eax
 0000120A  B8 0000000C	     1		mov eax, lightRed
 0000120F  E8 00000000 E     1		call SetTextColor
 00001214  58		     1		pop eax
					mWriteAt 20, 28, PlacementError
 00001215  52		     2		push edx
 00001216  B6 1C	     2		mov  dh,28
 00001218  B2 14	     2		mov  dl,20
 0000121A  E8 00000000 E     2		call Gotoxy
 0000121F  5A		     2		pop  edx
 00001220  52		     2		push edx
 00001221  BA 000006D5 R     2		mov  edx,OFFSET PlacementError
 00001226  E8 00000000 E     2		call WriteString
 0000122B  5A		     2		pop  edx
					mSetTextColor white
 0000122C  50		     1		push eax
 0000122D  B8 0000000F	     1		mov eax, white
 00001232  E8 00000000 E     1		call SetTextColor
 00001237  58		     1		pop eax
 00001238  BA 00000001			mov edx, 1
 0000123D  EB 00			jmp ValidH

 0000123F			ValidH:
					ret
 0000123F  5F		   *	    pop    edi
 00001240  59		   *	    pop    ecx
 00001241  58		   *	    pop    eax
 00001242  C3		   *	    ret    00000h
 00001243			DetectHorizontal ENDP


				end main
Microsoft (R) Macro Assembler Version 14.22.27905.0	    08/10/19 22:40:17
Battleship.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

IsDefined  . . . . . . . . . . .	Func
Startup  . . . . . . . . . . . .	Proc
mCheckShip . . . . . . . . . . .	Proc
mCheckSunk . . . . . . . . . . .	Proc
mDumpMem . . . . . . . . . . . .	Proc
mDump  . . . . . . . . . . . . .	Proc
mGotoxy  . . . . . . . . . . . .	Proc
mPause . . . . . . . . . . . . .	Proc
mReadString  . . . . . . . . . .	Proc
mSetTextColor  . . . . . . . . .	Proc
mShowRegister  . . . . . . . . .	Proc
mShow  . . . . . . . . . . . . .	Proc
mWriteAt . . . . . . . . . . . .	Proc
mWriteChar . . . . . . . . . . .	Proc
mWriteLn . . . . . . . . . . . .	Proc
mWriteSpace  . . . . . . . . . .	Proc
mWriteString . . . . . . . . . .	Proc
mWrite . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord
_INPUT_RECORD  . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  KeyEvent . . . . . . . . . . .	 00000004	 XmmWord
  MouseEvent . . . . . . . . . .	 00000004	 XmmWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 000007A2 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00001243 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

BoundedRandomNum . . . . . . . .	P Near	 00000E00 _TEXT	Length= 00000018 Public STDCALL
CalcShipsRemaining . . . . . . .	P Near	 0000046F _TEXT	Length= 0000007F Public STDCALL
CheckAttkPlayer  . . . . . . . .	P Near	 0000078E _TEXT	Length= 00000134 Public STDCALL
  YouMissed  . . . . . . . . . .	L Near	 000008BC _TEXT	
  YouGotEm . . . . . . . . . . .	L Near	 000008C1 _TEXT	
CheckComputerTurnHit . . . . . .	P Near	 00000C89 _TEXT	Length= 000000BE Public STDCALL
  HitB . . . . . . . . . . . . .	L Near	 00000CBF _TEXT	
  HitC . . . . . . . . . . . . .	L Near	 00000CDD _TEXT	
  HitD . . . . . . . . . . . . .	L Near	 00000CFB _TEXT	
  HitU . . . . . . . . . . . . .	L Near	 00000D19 _TEXT	
  Return . . . . . . . . . . . .	L Near	 00000D37 _TEXT	
CheckRandomCollision . . . . . .	P Near	 00000F29 _TEXT	Length= 0000009C Public STDCALL
  return . . . . . . . . . . . .	L Near	 00000FC4 _TEXT	
CheckShipCollision . . . . . . .	P Near	 00000FC5 _TEXT	Length= 00000034 Public STDCALL
  LoopOuter  . . . . . . . . . .	L Near	 00000FC9 _TEXT	
  LoopInner  . . . . . . . . . .	L Near	 00000FDD _TEXT	
  next . . . . . . . . . . . . .	L Near	 00000FED _TEXT	
  return . . . . . . . . . . . .	L Near	 00000FF6 _TEXT	
ClearDirections  . . . . . . . .	P Near	 00000D47 _TEXT	Length= 000000B9 Public STDCALL
CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ComputerShipSunk . . . . . . . .	P Near	 00000A5B _TEXT	Length= 00000052 Public STDCALL
ComputerTurn . . . . . . . . . .	P Near	 00000AAD _TEXT	Length= 000001DC Public STDCALL
  start  . . . . . . . . . . . .	L Near	 00000B2D _TEXT	
  cHit . . . . . . . . . . . . .	L Near	 00000B92 _TEXT	
  cMiss  . . . . . . . . . . . .	L Near	 00000BFB _TEXT	
  skip . . . . . . . . . . . . .	L Near	 00000BFB _TEXT	
  redraw . . . . . . . . . . . .	L Near	 00000C5D _TEXT	
  return . . . . . . . . . . . .	L Near	 00000C7C _TEXT	
ComputerWin  . . . . . . . . . .	P Near	 00000056 _TEXT	Length= 0000002E Public STDCALL
ConfirmRowCols . . . . . . . . .	P Near	 000008C2 _TEXT	Length= 00000066 Public STDCALL
  CheckRow . . . . . . . . . . .	L Near	 000008DF _TEXT	
  CheckCol . . . . . . . . . . .	L Near	 000008E5 _TEXT	
  BigHit . . . . . . . . . . . .	L Near	 000008ED _TEXT	
  ShipSunk . . . . . . . . . . .	L Near	 0000090D _TEXT	
  NextPlace  . . . . . . . . . .	L Near	 00000914 _TEXT	
  JustAHit . . . . . . . . . . .	L Near	 0000091F _TEXT	
  AllDone  . . . . . . . . . . .	L Near	 00000924 _TEXT	
ConvertColCoord  . . . . . . . .	P Near	 0000113B _TEXT	Length= 00000024 Public STDCALL
  SeekColumn . . . . . . . . . .	L Near	 00001146 _TEXT	
  ColumnFound  . . . . . . . . .	L Near	 00001157 _TEXT	
ConvertRowCoord  . . . . . . . .	P Near	 00001113 _TEXT	Length= 00000028 Public STDCALL
  SeekRow  . . . . . . . . . . .	L Near	 00001123 _TEXT	
  RowFound . . . . . . . . . . .	L Near	 00001133 _TEXT	
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DetectHorizontal . . . . . . . .	P Near	 000011D0 _TEXT	Length= 00000073 Public STDCALL
  CheckH . . . . . . . . . . . .	L Near	 000011E7 _TEXT	
  ErrorH . . . . . . . . . . . .	L Near	 000011F2 _TEXT	
  ValidH . . . . . . . . . . . .	L Near	 0000123F _TEXT	
DetectVertical . . . . . . . . .	P Near	 0000115F _TEXT	Length= 00000071 Public STDCALL
  CheckV . . . . . . . . . . . .	L Near	 00001176 _TEXT	
  ErrorV . . . . . . . . . . . .	L Near	 00001181 _TEXT	
  ValidV . . . . . . . . . . . .	L Near	 000011CC _TEXT	
DrawMap  . . . . . . . . . . . .	P Near	 000001E9 _TEXT	Length= 000001C6 Public STDCALL
  PrintTopRow  . . . . . . . . .	L Near	 0000020F _TEXT	
  CreatePlayerMap  . . . . . . .	L Near	 00000227 _TEXT	
  ChooseChar . . . . . . . . . .	L Near	 0000022D _TEXT	
  CheckPlayerHit . . . . . . . .	L Near	 0000024E _TEXT	
  CheckCarrier . . . . . . . . .	L Near	 0000026B _TEXT	
  CheckBattleship  . . . . . . .	L Near	 00000285 _TEXT	
  CheckSubmarine . . . . . . . .	L Near	 0000029F _TEXT	
  CheckDestroyer . . . . . . . .	L Near	 000002B9 _TEXT	
  CheckSweeper . . . . . . . . .	L Near	 000002D3 _TEXT	
  PrintPlayerMapCharacter  . . .	L Near	 000002ED _TEXT	
  PlayerCharPlaced . . . . . . .	L Near	 00000300 _TEXT	
  PlayerRowComplete  . . . . . .	L Near	 0000030D _TEXT	
  CreateComputerBoard  . . . . .	L Near	 00000342 _TEXT	
  PrintComputerRow . . . . . . .	L Near	 00000348 _TEXT	
  CheckComputerHit . . . . . . .	L Near	 00000366 _TEXT	
  PrintComputerMapCharacter  . .	L Near	 00000382 _TEXT	
  CompCharPlaced . . . . . . . .	L Near	 00000395 _TEXT	
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FillArrayH . . . . . . . . . . .	P Near	 00000F0F _TEXT	Length= 0000001A Public STDCALL
  Doug . . . . . . . . . . . . .	L Near	 00000F1C _TEXT	
FillArrayV . . . . . . . . . . .	P Near	 00000EF6 _TEXT	Length= 00000019 Public STDCALL
  Lisa . . . . . . . . . . . . .	L Near	 00000F03 _TEXT	
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCoordsH . . . . . . . . . . .	P Near	 00000E49 _TEXT	Length= 00000059 Public STDCALL
GetCoordsV . . . . . . . . . . .	P Near	 00000EA2 _TEXT	Length= 00000054 Public STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMouseAlt  . . . . . . . . . .	P Near	 00001029 _TEXT	Length= 00000001 Public STDCALL
GetMouseLoc  . . . . . . . . . .	P Near	 0000102A _TEXT	Length= 000000E9 Public STDCALL
  Begin  . . . . . . . . . . . .	L Near	 0000105A _TEXT	
  HandleLeftClick  . . . . . . .	L Near	 00001092 _TEXT	
  HandleRightClick . . . . . . .	L Near	 000010CC _TEXT	
  skip . . . . . . . . . . . . .	L Near	 00001106 _TEXT	
  Complete . . . . . . . . . . .	L Near	 0000110F _TEXT	
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetRandomOdd . . . . . . . . . .	P Near	 00000E18 _TEXT	Length= 00000031 Public STDCALL
  decrement  . . . . . . . . . .	L Near	 00000E44 _TEXT	
  Found  . . . . . . . . . . . .	L Near	 00000E45 _TEXT	
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Init . . . . . . . . . . . . . .	P Near	 000000B2 _TEXT	Length= 00000016 Public STDCALL
Intro  . . . . . . . . . . . . .	P Near	 000000C8 _TEXT	Length= 000000CE Public STDCALL
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LogHit . . . . . . . . . . . . .	P Near	 00000928 _TEXT	Length= 0000007A Public STDCALL
LogMiss  . . . . . . . . . . . .	P Near	 000009A2 _TEXT	Length= 00000069 Public STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PlaceCompShip  . . . . . . . . .	P Near	 00000722 _TEXT	Length= 0000006C Public STDCALL
  RetryThis  . . . . . . . . . .	L Near	 00000722 _TEXT	
  RandV  . . . . . . . . . . . .	L Near	 0000075A _TEXT	
  CheckColl  . . . . . . . . . .	L Near	 00000772 _TEXT	
PlaceComputerShips . . . . . . .	P Near	 00000668 _TEXT	Length= 000000BA Public STDCALL
PlacePlayerShips . . . . . . . .	P Near	 000004EE _TEXT	Length= 00000100 Public STDCALL
PlaceShip  . . . . . . . . . . .	P Near	 000005EE _TEXT	Length= 0000007A Public STDCALL
  RetryThis  . . . . . . . . . .	L Near	 000005EE _TEXT	
  ItsVertical  . . . . . . . . .	L Near	 0000061A _TEXT	
  Luigi  . . . . . . . . . . . .	L Near	 0000062B _TEXT	
  ItsHorizontal  . . . . . . . .	L Near	 00000634 _TEXT	
  Mario  . . . . . . . . . . . .	L Near	 00000645 _TEXT	
  BonVoyage  . . . . . . . . . .	L Near	 0000064C _TEXT	
PlayerShipSunk . . . . . . . . .	P Near	 00000A0B _TEXT	Length= 00000050 Public STDCALL
PlayerTurn . . . . . . . . . . .	P Near	 00000196 _TEXT	Length= 00000053 Public STDCALL
PlayerWin  . . . . . . . . . . .	P Near	 00000084 _TEXT	Length= 0000002E Public STDCALL
PrintBottomText  . . . . . . . .	P Near	 000003AF _TEXT	Length= 000000C0 Public STDCALL
PrintShipInstructions  . . . . .	P Near	 00000FF9 _TEXT	Length= 00000030 Public STDCALL
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000056 Public STDCALL
  GameLoop . . . . . . . . . . .	L Near	 0000001E _TEXT	
  PlayerWin  . . . . . . . . . .	L Near	 0000003F _TEXT	
  ComputerWin  . . . . . . . . .	L Near	 00000046 _TEXT	
  AnotherTurn  . . . . . . . . .	L Near	 0000004D _TEXT	
  GameOver . . . . . . . . . . .	L Near	 0000004F _TEXT	
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

??0000 . . . . . . . . . . . . .	Byte	 0000072C _DATA	
??0001 . . . . . . . . . . . . .	Byte	 0000072E _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
BattleshipLabel  . . . . . . . .	Byte	 00000530 _DATA	
BeginText  . . . . . . . . . . .	Byte	 00000380 _DATA	
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
COL_COORD  . . . . . . . . . . .	Word	 00000706 _DATA	
COL_MAX  . . . . . . . . . . . .	Byte	 00000168 _DATA	
COL_MIN  . . . . . . . . . . . .	Byte	 00000167 _DATA	
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CarrierLabel . . . . . . . . . .	Byte	 00000544 _DATA	
CompPlacedAll  . . . . . . . . .	Byte	 00000458 _DATA	
ComputerLabel  . . . . . . . . .	Byte	 000003BE _DATA	
ComputerMap  . . . . . . . . . .	Byte	 00000264 _DATA	
ConsoleMode  . . . . . . . . . .	DWord	 00000720 _DATA	
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
Defeat . . . . . . . . . . . . .	Byte	 000006AC _DATA	
DestroyerLabel . . . . . . . . .	Byte	 00000568 _DATA	
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
HealthLabel  . . . . . . . . . .	Byte	 0000043D _DATA	
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
InputRecord  . . . . . . . . . .	_INPUT_RECORD  0000070C	_DATA	
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
MAP_INDEX  . . . . . . . . . . .	DWord	 00000708 _DATA	
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
PlaceDirection . . . . . . . . .	Byte	 000003DD _DATA	
PlaceHorizontal  . . . . . . . .	Byte	 00000423 _DATA	
PlaceTitle . . . . . . . . . . .	Byte	 000003CE _DATA	
PlaceVertical  . . . . . . . . .	Byte	 0000040C _DATA	
PlacementError . . . . . . . . .	Byte	 000006D5 _DATA	
PlayerLabel  . . . . . . . . . .	Byte	 000003AD _DATA	
PlayerMap  . . . . . . . . . . .	Byte	 0000016B _DATA	
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ROW_COORD  . . . . . . . . . . .	Word	 00000704 _DATA	
ROW_MAX  . . . . . . . . . . . .	Byte	 0000016A _DATA	
ROW_MIN  . . . . . . . . . . . .	Byte	 00000169 _DATA	
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
RemainingLabel . . . . . . . . .	Byte	 00000446 _DATA	
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
ShipsPlaced  . . . . . . . . . .	Byte	 00000155 _DATA	
SubmarineLabel . . . . . . . . .	Byte	 00000555 _DATA	
SweeperLabel . . . . . . . . . .	Byte	 0000057A _DATA	
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
Victory  . . . . . . . . . . . .	Byte	 0000063A _DATA	
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
_B_  . . . . . . . . . . . . . .	Byte	 00000162 _DATA	
_C_  . . . . . . . . . . . . . .	Byte	 00000161 _DATA	
_D_  . . . . . . . . . . . . . .	Byte	 00000164 _DATA	
_EMPTY_  . . . . . . . . . . . .	Byte	 00000166 _DATA	
_S_  . . . . . . . . . . . . . .	Byte	 00000165 _DATA	
_U_  . . . . . . . . . . . . . .	Byte	 00000163 _DATA	
allShipsPlaced . . . . . . . . .	Byte	 000005F0 _DATA	
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
cTurnNotice  . . . . . . . . . .	Byte	 000004D0 _DATA	
cTurnResult  . . . . . . . . . .	Byte	 00000506 _DATA	
clearLine  . . . . . . . . . . .	Byte	 0000073C _DATA	
compBshipArray . . . . . . . . .	Byte	 00000368 _DATA	
compBshipHealth  . . . . . . . .	Byte	 0000035A _DATA	
compCarrierArray . . . . . . . .	Byte	 0000035E _DATA	
compCarrierHealth  . . . . . . .	Byte	 00000359 _DATA	
compDestroyerArray . . . . . . .	Byte	 00000376 _DATA	
compDestroyerHealth  . . . . . .	Byte	 0000035C _DATA	
compHealth . . . . . . . . . . .	Byte	 00000358 _DATA	
compSubArray . . . . . . . . . .	Byte	 00000370 _DATA	
compSubHealth  . . . . . . . . .	Byte	 0000035B _DATA	
compSweeperArray . . . . . . . .	Byte	 0000037C _DATA	
compSweeperHealth  . . . . . . .	Byte	 0000035D _DATA	
computerPlacementComplete  . . .	Byte	 000005D9 _DATA	
computerShipSunkMsg  . . . . . .	Byte	 0000061D _DATA	
computerTurnResult . . . . . . .	Byte	 0000048C _DATA	
currOffset . . . . . . . . . . .	DWord	 0000015B _DATA	
currShipChar . . . . . . . . . .	Byte	 00000158 _DATA	
currShipHealth . . . . . . . . .	Byte	 00000159 _DATA	
currShipSize . . . . . . . . . .	Byte	 00000157 _DATA	
currShip . . . . . . . . . . . .	Byte	 0000015A _DATA	
currentCol . . . . . . . . . . .	Byte	 000007A0 _DATA	
currentRow . . . . . . . . . . .	Byte	 000007A1 _DATA	
cyan . . . . . . . . . . . . . .	Number	 00000003h   
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
hStdln . . . . . . . . . . . . .	DWord	 00000724 _DATA	
hitBool  . . . . . . . . . . . .	Byte	 0000015F _DATA	
hitResult  . . . . . . . . . . .	Byte	 00000525 _DATA	
intersect  . . . . . . . . . . .	Byte	 00000160 _DATA	
intro1 . . . . . . . . . . . . .	Byte	 00000000 _DATA	
intro2 . . . . . . . . . . . . .	Byte	 00000019 _DATA	
intro3 . . . . . . . . . . . . .	Byte	 00000029 _DATA	
intro4 . . . . . . . . . . . . .	Byte	 00000077 _DATA	
intro5 . . . . . . . . . . . . .	Byte	 000000A2 _DATA	
intro6 . . . . . . . . . . . . .	Byte	 000000F9 _DATA	
intro7 . . . . . . . . . . . . .	Byte	 00000134 _DATA	
isSunk . . . . . . . . . . . . .	Byte	 00000357 _DATA	
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
lowerBound . . . . . . . . . . .	DWord	 00000738 _DATA	
magenta  . . . . . . . . . . . .	Number	 00000005h   
missResult . . . . . . . . . . .	Byte	 0000052A _DATA	
mouseNum . . . . . . . . . . . .	Byte	 00000156 _DATA	
nRead  . . . . . . . . . . . . .	DWord	 00000728 _DATA	
numCols  . . . . . . . . . . . .	Byte	 00000154 _DATA	
numRows  . . . . . . . . . . . .	Byte	 00000153 _DATA	
pTurnNotice  . . . . . . . . . .	Byte	 000004AB _DATA	
pTurnResult  . . . . . . . . . .	Byte	 000004EB _DATA	
playerBattleshipHealth . . . . .	Byte	 00000260 _DATA	
playerCarrierHealth  . . . . . .	Byte	 0000025F _DATA	
playerDestroyerHealth  . . . . .	Byte	 00000262 _DATA	
playerHealth . . . . . . . . . .	Byte	 0000025E _DATA	
playerPlacementComplete  . . . .	Byte	 0000059D _DATA	
playerShipSunkMsg  . . . . . . .	Byte	 0000060C _DATA	
playerSubmarineHealth  . . . . .	Byte	 00000261 _DATA	
playerSweeperHealth  . . . . . .	Byte	 00000263 _DATA	
playerTurnResult . . . . . . . .	Byte	 0000046F _DATA	
red  . . . . . . . . . . . . . .	Number	 00000004h   
savedLocation  . . . . . . . . .	DWord	 00000730 _DATA	
savedShiphealth  . . . . . . . .	Byte	 0000079F _DATA	
shipToPlace  . . . . . . . . . .	Byte	 0000058B _DATA	
upperBound . . . . . . . . . . .	DWord	 00000734 _DATA	
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
